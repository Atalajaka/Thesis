%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       CARREGA DE LA CLASSE DE DOCUMENT                      %
%                                                                             %
% Les opcions admissibles son:                                                %
%      12pt / 11pt            (cos dels tipus de lletra; no feu servir 10pt)  %
%                                                                             %
% catalan/spanish/english     (llengua principal del treball)                 %
%                                                                             % 
% french/italian/german...    (si necessiteu fer servir alguna altra llengua) %
%                                                                             %
% listoffigures               (El document inclou un Index de figures)        %
% listoftables                (El document inclou un Index de taules)         %
% listofquadres               (El document inclou un Index de quadres)        %
% listofalgorithms            (El document inclou un Index d'algorismes)      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,spanish,listoffigures,listoftables,listofalgorithms]{tfgetsinf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     CODIFICACIO DEL FITXER FONT                             %
%                                                                             %
%    windows fa servir normalment 'ansinew'                                   %
%    amb linux es possible que siga 'latin1' o 'latin9'                       %
%    Pero el mes recomanable es fer servir utf8 (unicode 8)                   %
%                                          (si el vostre editor ho permet)    % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{float}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{bookmark}
\usepackage{algorithm}
%\usepackage{algorithmic}
\definecolor{y}{RGB}{180, 180, 0}
\definecolor{g}{RGB}{50, 170, 50}
\definecolor{b}{RGB}{0, 100, 230}
\definecolor{r}{RGB}{255, 0, 0}
\newcommand{\hash}{\textit{hash}}
\newcommand{\hashes}{\textit{hashes}}
\renewcommand{\algorithmname}{Algoritmo}
\renewcommand{\algorithmicrequire}{\textbf{Entrada:}}
\renewcommand{\algorithmicensure}{\textbf{Salida:}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        ALTRES PAQUETS I DEFINICIONS                         %
%                                                                             %
% Carregueu aci els paquets que necessiteu i declareu les comandes i entorns  %
%                                          (aquesta seccio pot ser buida)     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        DADES DEL TREBALL                                    %
%                                                                             %
% titol, alumne, tutor i curs academic                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Adivinando passwords \\
         Una propuesta para su búsqueda eficiente}
\author{Alejandro Mor Michael}
\tutor{Damián López Rodríguez}
\curs{2018 - 2019}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     PARAULES CLAU/PALABRAS CLAVE/KEY WORDS                  %
%                                                                             %
% Independentment de la llengua del treball, s'hi han d'incloure              %
% les paraules clau i el resum en els tres idiomes                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\keywords{criptografia, indentificació, password, funció resum, taula rainbow} % Paraules clau 
         {criptografía, identificación, password, función resumen, tabla del arco iris}  % Palabras clave
         {criptography, identification, password, hash function, rainbow table}      % Key words

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              INICI DEL DOCUMENT                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              RESUMS DEL TFG EN VALENCIA, CASTELLA I ANGLES                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}[spanish]
El acceso a los sistemas informáticos está desde siempre ligado a la utilización de palabras de paso o passwords. Por motivos de seguridad, los passwords se han almacenado de forma oculta en los sistemas, siendo habitualmente el resultado de la aplicación de una función resumen -o hash- sobre el password. Dichas funciones resumen tienen una gran relevancia para el mantenimiento seguro de los passwords. También son invertibles, con una probabilidad de colisión inversamente proporcional de forma exponencial al número de bits del resumen. Una aproximación para encontrar dichas colisiones se basa en la construcción de las denominadas tablas del arco iris, que emplean una aproximación \textit{time-memory trade-off} (TMTO), mostrándose eficientes a la hora de encontrar colisiones y posibilitando el acceso no autorizado a los sistemas.
\end{abstract}

\begin{abstract}[catalan]
L'accés al sistemes informàtics ha estat des-de sempre lligat a l'ús de paraules de pas o passwords. Per motius de seguretat, els passwords son emmagatzemats de forma oculta als sistemes, seguint habitualment el resultat de l'aplicació d'una funció resum -o hash- sobre el password. Aquestes funcions resum tenen una gran rellevància a l'hora de mantindre els passwords segurament. També son invertibles, amb una probabilitat de col·lisió inversament proporcional exponencialment al nombre de bits del resum. Una aproximació per a encontrar dites col·lisions son les denominades taules $rainbow$, que fan ús d'una aproximació \textit{time-memory trade-off} (TMTO), mostrant-se eficients a l'hora d'encontrar col·lisions i possibilitant l'accés no autoritzat als sistemes.
\end{abstract}

\begin{abstract}[english]
Access to computer systems has always been tied to the use of passwords. For security reasons, passwords are stored in an occult manner, being usually the result of a hash function on the password. Said hash functions are highly relevant for safe-keeping passwords. They are also reversible, having a collision probability inversely proportional exponentially to the number of bits in the hash. An approximation for finding such collisions is based in the generation of the so called rainbow tables, which make use of a time-memory trade-off (TMTO), showing efficiency when looking for those collisions and allowing unauthorised access to the systems.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              CONTINGUT DEL TREBALL                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  INTRODUCCIÓN                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introducci\'on}

% El uso de funciones resumen en criptografía está basado en la complejidad de encontrar colisiones para un resumen dado. Dicha complejidad hace inviables los ataques basados en fuerza bruta, por lo que si se pretende obtener resultados satisfactorios, han de llegar necesariamente desde mejores aproximaciones. Es por ello que con el tiempo han surgido varias de estas aproximaciones capaces de mejorar los resultados de la fuerza bruta de forma significante, haciendo viable la búsqueda de colisiones para un resumen ya sabido.

La criptografía se puede definir como el estudio de técnicas matemáticas relacionadas con el mantenimiento seguro de cualquier tipo de información\cite{handbook}. Tiene una historia muy extensa, existiendo pruebas de sus primeros usos hace 4000 años, pasando por las primeras implementaciones en los sistemas informáticos hasta llegar al momento actual. Ligado al aumento del acceso a los sistemas informáticos surgió una nueva demanda de acceso a medios de protección de información digital, lo cual sirvió como estímulo para la investigación y obtención de nuevas técnicas y métodos de mantenimiento seguro de la información almacenada en los sistemas informáticos.

\section{La criptografía como piedra angular}

%\subsection{Definición}

%\subsection{Características básicas y usos populares}

Existen infinidad de motivos interesantes para proteger información digital privada de forma segura, pudiendo ser los más destacados los siguientes:

\begin{enumerate}
	
	\item \textbf{Confidencialidad}: mantener la información privada oculta excepto para quienes tengan autorización para su obtención. Hoy en día, es habitual emplear algoritmos matemáticos con el fin de hacer la información ininteligible para usuarios no autorizados.
	
	\item \textbf{Autenticación}: sirve como método de identificación, pudiéndose aplicar tanto a entidades interesadas en información como a la propia información.

	\item \textbf{Integridad de datos}: relacionado con la modificación no autorizada de información. Es necesario poseer la habilidad de detectar cualquier alteración de los datos por un usuario no autorizado si se desea garantizar la integridad de dichos datos.

	\item \textbf{No repudiación}: prevenir la negación de la realización de acciones previas, o lo que es lo mismo asegurar la realización de acciones previas.

	\item \textbf{Firma}: dejar información específica ligada a una entidad de confianza.

\end{enumerate}

Los métodos criptográficos más populares consisten en el cifrado de mensajes y el uso de la firma electrónica. Con los objetivos vistos arriba en mente, una de las herramientas más comunes para llevar a cabe estos métodos son las funciones resumen.

\section{Características y usos de las funciones resumen}

Aunque existen una gran variedad de técnicas criptográficas con el objetivo en mente de garantizar los puntos anteriores, en este proyecto el foco ha sido puesto mayoritariamente en la utilización de una de ellas: las funciones resumen. En concreto, se buscará introducir una implementación que suponga una mejora respecto a procedimientos anteriores empleados para la búsqueda de colisiones para este tipo de funciones.

\subsection{Definición}

También conocidas como funciones \hash, estas funciones son aquellas que actúan sobre mensajes de longitud arbitraria, tomándolos como entrada y produciendo como salida una cadena de longitud fija. A dicha salida producida por una función \hash~se le denomina un resumen -o valor- \hash, también pudiendo referirse a ella simplemente como un \hash.

Una función resumen $h$ ha de cumplir que, para una cadena binaria de salida $x$ de longitud igual a $n$ bits, la probabilidad de que un mensaje de entrada $m$ aleatorio resulte en un valor \hash~igual que $x$ es de $2^{-n}$. Esto es lo que se conoce como una colisión, lo cual representa el punto central de este proyecto y se explicará en detalle más adelante.

%Uno de los usos criptográficos más comunes para las funciones resumen tiene lugar en protocolos de integridad de información. Las implementaciones que emplean funciones \hash~con este objetivo suelen un funcionamiento común, como se puede ver a continuación:

%\begin{enumerate}

%	\item Se computa el valor \hash~de ciertos datos del sistema, cuya integridad queda protegida.

%	\item En cierto momento posterior, con el objetivo de verificar que los datos que se encuentran en el sistema no han sido alterados, el valor \hash~de dichos datos se computa de nuevo y es comparado con el original. En el caso de ser diferentes se puede asegurar que se ha llevado a cabo algún tipo de modificación no autorizada de los datos.

%\end{enumerate}

\subsection{Propiedades}\label{props}

Las funciones resumen poseen diversas características además de las vistas en el anterior apartado, las cuales resultan de gran utilidad para su uso. Las más notables son las siguientes:

\begin{itemize}

	\item \textbf{Computación eficiente}: obtener un resumen \hash~para un mensaje de entrada dado se realiza rápidamente. Aunque parezca una necesidad obvia, es de vital importancia para el uso de funciones \hash~en protocolos criptográficos.

    \item \textbf{Determinismo}: un mensaje de entrada dado siempre producirá la misma cadena de salida.

    \item \textbf{Uniformidad}: los posibles valores \hash~de una función resumen deben de tener la misma probabilidad de ser generados.

    \item \textbf{Altamente susceptibles}: dados un mensaje $m$ y su correspondiente valor \hash~$h_m$, alterar algunos bits de $m$ genera un valor \hash~$h'_m$ el cual es tan diferente a $h_m$ que no parecen estar relacionados, es decir, comparando ambos valores \hash~no es posible apreciar que provienen de mensajes muy similares.

\end{itemize}

Existen también otro tipo de características que sirven para determinar el nivel de seguridad de una función resumen en particular, las cuales son conocidas como las resistencias. Existen tres tipos diferentes, y dependiendo de a cuáles de ellas sea resistente una función \hash~se podrá establecer su grado de seguridad:

\begin{enumerate}

	\item \textbf{Pre-imagen}: conociendo un valor \hash $y$ sin conocer su mensaje de entrada original, es computacionalmente inviable encontrar un mensaje de entrada $m$ que genere $y$ como valor \hash, es decir $h(m) = y$. En este caso, el mensaje $m$ es considerado como la pre-imagen.
 
	\item \textbf{Segunda pre-imagen}: conociendo un mensaje de entrada $m$, es computacionalmente inviable encontrar otro mensaje de entrada diferente $m'$ de tal forma que el valor \hash~producido por ambos mensajes sea el mismo, tal y como $h(m) = h(m')$. En este caso, el mensaje $m'$ es considerado como la segunda pre-imagen.

	\item \textbf{Colisión}: Resulta computacionalmente inviable encontrar dos mensajes de entrada diferentes entre sí, $m_1$ y $m_2$, los cuales generan el mismo valor \hash, de tal forma que $h(m_1) = h(m_2)$.

\end{enumerate}

Cabe remarcar que en cuanto a estas resistencias, la diferencia entre la resistencia a segunda pre-imagen y a colisión se debe a que en la segunda pre-imagen, el primer mensaje ha sido interceptado por un atacante, mientras que en la colisión no se ha obtenido ningún mensaje de entrada.

Como ya ha sido indicado anteriormente, las colisiones constituyen uno de los puntos fundamentales de este proyecto. Su obtención para una función resumen puede representar una vulnerabilidad, pudiendo de esta forma sortear la barrera que representan.

\subsection{Usos populares}

Aunque existen una gran variedad de aplicaciones de las funciones resumen, dos de los más populares son los vistos a continuación:

\begin{itemize}
		
	\item \textbf{Firma electrónica}: este tipo de protocolos son empleados  para verificar la autenticidad de mensajes o documentos digitales. Las funciones \hash~constituyen una parte fundamental para llevar a cabo este objetivo, como se puede ver en el siguiente ejemplo, el cual representa un intercambio de información digital de un mensaje $x$ entre dos entidades, desde $E1$ para $E2$, empleando una función resumen $h$ y una firma electrónica $F$:

		\begin{enumerate}
				
			\item Ambas entidades $E1$ y $E2$ se ponen de acuerdo en la función resumen $h$ a emplear.

			\item La entidad firmante, $E1$, desea mandar un mensaje $x$ a la entidad $E2$. Para ello, manda una tupla $t$ que consiste en el mensaje $x$ por una parte, y por la otra la firma del valor \hash~de $x$, de tal forma que $t = \{x, F[h(x)]\}$.

			\item La entidad receptora, $E2$, al recibir la tupla $t$ verifica que ha sido mandada por $E1$ obteniendo el valor \hash~del mensaje $x$, de tal manera que si coincide con lo recibido todo ha ido según lo esperado, mientras que si no es así puede indicar un uso ilegítimo del sistema.

		\end{enumerate}

	\item \textbf{Acceso a un sistema mediante una contraseña}: sea un sistema operativo o la cuenta de usuario de una página web, el uso de contraseñas para ganar acceso a un entorno funciona mediante la utilización de las funciones resumen. Al asociar una contraseña a un usuario, la información almacenada en el sistema no es la contraseña como tal, sino su valor \hash. En el caso de tratar de acceder a un sistema que emplea una función resumen $h$, al introducir una contraseña $p$ se calcula su valor \hash~$h(p)$, y se comprueba que sea igual que el valor asociado al usuario en cuestión. Si coinciden, se garantiza el acceso, de lo contrario siendo denegado.

\end{itemize}

En ambos casos, el método de superar la barrera impuesta por la función resumen es el mismo: encontrar una colisión para el valor \hash~deseado.

\section{Motivaci\'on}

%El hecho de que las contraseñas traten de ocultarse empleando técnicas criptográficas no ha supuesto un impedimento para su obtención no autorizada. En la mayoría de casos, se podría decir que dicha ocultación tan sólo ha servido para retrasar lo inevitable, ya que ha sido posible implementar ataques que han conseguido hacerse con ellas, demostrando fallos de seguridad en las técnicas criptográficas empleadas.
%
%En concreto, la obtención de contraseñas para el acceso a un sistema informático siempre ha resultado ser de muy elevado interés para atacantes malintencionados, debido a la magnitud de la posible recompensa una vez conseguido llevar a cabo su ataque con éxito.
%
%En este proyecto, el ataque presentado demuestra la debilidad y vulnerabilidad de algunas funciones resumen empleadas para dicha ocultación de contraseñas. Al mismo tiempo, aunque la experimentación se ha realizado en un contexto muy específico, quedará reflejada la utilidad de tener acceso a una herramienta de búsqueda de colisiones contra una función resumen, debido a que de esta forma será posible determinar la seguridad de dicha función resumen en un caso práctico.

La obtención de colisiones dentro de las funciones resumen sirve para vulnerar y en muchos casos inutilizar la protección que tratan de proporcionar.

Aunque inicialmente pueda resultar una tarea que requiera grandes cantidades de tiempo y memoria, existen métodos que consiguen reducir estos requerimientos con el fin de obtener dichas colisiones de manera eficiente. Dichos métodos se han ido mejorando con el paso del tiempo, quedando a su vez inutilizados por las medidas de seguridad que surgían como contramedida. Así mismo, las funciones \hash~han evolucionado acordemente, tratando de resultar más seguras contra estos métodos.

Estos avances han llevado al momento actual, en el cual se tiene acceso a una gran variedad de técnicas de obtención de colisiones para funciones \hash, algunas más eficientes que otras, así como la disponibilidad de cientos de funciones resumen. El interés de obtener una implementación capaz de hacerse con sus colisiones reside en diferentes ámbitos, desde la obtención no autorizada de información hasta la experimentación con diferentes funciones resumen para determinar sus grados de seguridad frente a estos ataques.

\section{Objetivos}

El objetivo principal de este trabajo consiste en diseñar un método eficiente de búsqueda de colisiones para funciones resumen. De esta manera se obtendría una implementación capaz de atacar cualquier función \hash~con el objetivo de encontrar colisiones dentro de la misma, pudiendo ser empleada para diversos fines relacionados con el uso de estas funciones. Así mismo, la implementación desarrollada tendrá como objetivo adicional representar una mejora respecto a métodos anteriores, siguiendo un esquema ya establecido que consigue obtener dicha mejora. Dentro del mismo, se tratará de encontrar la implementación más eficiente, lo cual requerirá una amplia fase de experimentación.

%Para llevarlo a cabo, se implementará un sistema de búsqueda que, tomando una función \hash~y un formato específico de contraseñas, simulará un mecanismo de almacenaje de las mismas que proporcionan la entrada a un sistema operativo, estando estas contraseñas protegidas por la función resumen antes establecida, mientras durante la búsqueda se trata de adivinar el mayor número posible de contraseñas. De esta manera, dos aspectos diferentes pueden ser evaluados. En primer lugar la seguridad de la función resumen empleada, la cual quedará reflejada mediante la cantidad de contraseñas adivinadas que trataba de proteger. En segundo lugar, será posible comprobar tanto la eficiencia como la eficacia del sistema de búsqueda de colisiones, lo cual puede resultar de interés a la hora de emplear una herramienta capaz de evaluar la seguridad de una función resumen a elegir.

\section{Estructura de la memoria}

Habiendo establecido una base introduciendo conceptos fundamentales tanto de la criptografía como de las funciones resumen, los siguientes capítulos se distribuirán de la siguiente forma:

\begin{itemize}

	\item En el siguiente capítulo se expondrán diferentes métodos de obtención de colisiones para funciones resumen, los cuales constituirán una base sobre la cual cimentar los capítulos venideros.

	\item En el tercer capítulo tendrá lugar la explicación en detalle del método empleado en este proyecto para la búsqueda de colisiones de funciones \hash, relacionándolo con las aproximaciones vistas en el anterior capítulo y sirviendo como preámbulo a la experimentación desarrollada.

	\item En el capítulo cuatro se entrará en detalle de la implementación desarrollada para obtener un método eficiente de búsqueda de colisiones para funciones resumen, exponiendo las especificaciones establecidas y los resultados obtenidos a lo largo de todo el desarrollo.

	\item En el capítulo final se realizarán las conclusiones finales sobre todo lo visto, analizando los resultados obtenidos en el anterior capítulo y estableciendo posibles trabajos futuros.

\end{itemize}

%Una vez establecidos los trabajos previos se podrá presentar el funcionamiento del ataque implementado, y tras ello pasar a exponer en detalle la implementación desarrollada, mostrando el proceso seguido, los resultados obtenidos y realizando posteriormente un análisis de los mismos.
%
%Por último, tras haber establecido los resultados obtenidos se dará lugar a las conclusiones de todo lo visto y a un análisis de las ventajas que podría tener el uso de la implementación desarrollada, así como establecer hacia dónde se enfocaría el trabajo futuro con objetivo de mejorar lo obtenido.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       CAPÍTULOS (tantos como haga falta)                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Aproximaciones en la búsqueda de colisiones en funciones resumen}

El dicho popular "hecha la ley, hecha la trampa"\,también es aplicable en el campo de la criptografía, y dentro de todas sus posibilidades, las funciones resumen no quedan exentas. Aunque desde la aparición de estas funciones se han desarrollado infinidad de ataques diferentes, cada uno basándose en diferentes propiedades, los más relevantes para este proyecto vienen dados a continuación.

\section{La paradoja del cumpleaños}

La paradoja del cumpleaños tiene lugar en teoría de la probabilidad, y recibe su nombre del siguiente suceso. Si se toma un grupo de $p$ personas, existe una probabilidad de que dos de ellas tengan la misma fecha de nacimiento en cuanto al día y el mes, sin tener en cuenta el año. Es evidente que si se dispone de 367 personas, existe un 100\% de probabilidad de que al menos dos de ellas coincidan en este aspecto, ya que existen un total de 366 fechas de nacimiento diferente, incluyendo el 29 de febrero. La paradoja del cumpleaños toma forma cuando se dispone de un número menor de personas, ya que con tan sólo 70 personas, la probabilidad de que dos de ellas tengan el mismo cumpleaños asciende hasta el 99.9\%, mientras que con únicamente 23 personas existe una probabilidad del 50\% de que tenga lugar esta ocurrencia, como puede observarse en~\cite{birthday}.

Extrapolando la paradoja del cumpleaños a las funciones \hash, puede tomarse como ejemplo una función $h$ que genere resúmenes con una longitud de $n$ bits. En este caso, el número total de valores \hash~diferentes que pueden obtenerse mediante $h$ es de $2^n$. Sabiendo esto, si se pretendiera adivinar un valor \hash~aleatorio de $h$, sería necesario llevar a cabo $\mathcal{O}(2^n)$ operaciones, considerando la obtención de un resumen \hash~como una operación. Debido a la paradoja del cumpleaños, normalmente no va a ser necesario realizar tantos pasos, ya que tras realizar $\mathcal{O}(2^{\frac{n}{2}})$ pasos muy probablemente se habrá obtenido el valor deseado \cite{handbook}. Esto ocurre siguiendo una propiedad fundamental de la paradoja del cumpleaños, la cual especifica que en un problema de este tipo, contando con $n$ elementos o candidatos, tras realizar $\mathcal{O}(\sqrt{n})$ selecciones existe una probabilidad muy alta de encontrar una coincidencia.

De esta manera surgieron los ataques del cumpleaños, basados en la paradoja homónima. Este tipo de ataques a funciones \hash~tan sólo tienen en cuenta el número de bits que poseen los valores \hash~y el tiempo empleado en la obtención de uno de estos valores.

\subsection{El algoritmo de Yuval aplicado al ataque del cumpleaños}

Una de las implementaciones más populares del ataque del cumpleaños vino dada por Yuval, consiguiendo con éxito ser capaz de encontrar colisiones en las funciones \hash~de aquel momento. La forma de llevar a cabo este ataque contra un sistema de firma electrónica es el siguiente:

\begin{algorithm}[H]
	\caption{Algoritmo de Yuval aplicando el ataque del cumpleaños}\label{Yuval}
	\begin{algorithmic}
		\REQUIRE mensaje legítimo $m_1$, mensaje fraudulento $m_2$, función \hash~$h$ que genera resúmenes de $n$ bits de longitud, $t = 0$.
		\ENSURE $m_1',\, m_2'$ resultantes de aplicar modificaciones menores a $m_1,\, m_2$, tal que $h(m_1') = h(m_2')$ (de esta forma la firma funcionaría tanto con $m_1'$ como con $m_2'$).
		\STATE ~
		\WHILE{$t < 2^{\frac{n}{2}}$}
		\STATE Generar mensajes fraudulentos $m_1'$, resultados de aplicar modificaciones menores de $m_1$.
		\STATE Obtener el valor \hash~de cada $m_1'$ y guardarlo junto con su mensaje originario, para poder obtener el mensaje cuando se busque un valor \hash.
		\ENDWHILE
		\STATE ~
		\WHILE{$h(m_1') \neq h(m_2')$} 
		\STATE Generar mensajes fraudulentos $m_2'$ mediante modificaciones menores de $m_2$, cada vez obteniendo su valor \hash~correspondiente y comprobando si coincide con alguno de los valores \hash~de cualquiera de los $m_1'$, deteniendo en proceso una vez se encuentre tal coincidencia.
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

Relacionando este ataque con la paradoja del cumpleaños, tras realizar $\mathcal{O}(2^{\frac{n}{2}})$ operaciones la probabilidad de encontrar una colisión se eleva de manera significativa. Esto llegó a plantear un serio problema para algunos métodos de firma electrónica de la época, ya que permitía usurpar la identidad de cualquier usuario de un sistema de firma electrónica vulnerable.

\section{\textit{Time-memory trade-off}} \label{tmto}

En julio de 1980 era publicado por Martin E. Hellman el primer artículo introduciendo el concepto del intercambio tiempo-memoria \cite{hellman}(dicho intercambio será referido a partir de ahora como TMTO). En dicho artículo, Hellman indica como el TMTO se puede aplicar con el objetivo de averiguar la información necesaria para descifrar textos de forma más eficiente que anteriormente visto. Para este fin emplea estructuras de datos en forma de tablas, que sirven como piedra angular para el desarrollo de este tipo de ataques criptográficos.

El TMTO ya había sido implementado anteriormente con éxito, por ejemplo en los problemas de la mochila~\cite{knapsack} o del logaritmo discreto~\cite{logarithm} en sus espacios de búsqueda respectivos. De tal forma, si existen un total de $N$ soluciones posibles en el espacio de búsqueda, el TMTO permite encontrar la solución deseada en $T$ pasos empleando $M$ palabras de memoria, siempre que se cumpla que $T \cdot M = N$. Esto resulta ser mucho más eficiente en cuanto al tiempo empleado que la búsqueda por fuerza bruta, la cual puede requerir $N$ pasos para encontrar una solución.

\subsection{Parámetros a tener en cuenta}\label{params}

Para el correcto desarrollo del método ideado por Hellman, son necesarios  los siguientes parámetros:

\begin{itemize}

    \item $P$: conjunto de posibles textos sin cifrar.
    
    \item $C$: conjunto de posibles textos cifrados.
    
    \item $K$: conjunto de claves empleadas para cifrar los textos de $P$, transformándolos en textos de $C$.
    
    \item $R$: función de reducción que transforma textos cifrados de $C$ en claves de $K$.
    
    \item $m$: número de filas de la tabla.
    
    \item $t$: número de columnas de la tabla.

\end{itemize}

El uso de los parámetros $P, C$ y $K$ es sencillo. Un texto sin cifrar $p \in P$ pasa a ser un texto cifrado $c \in C$ mediante el uso de una clave $k \in K$. De esta manera, si se pretende averiguar el texto original $p$ habiendo obtenido el texto cifrado, es necesario conocer la clave $k$ para descifrar $c$.

Para ejemplificar la construcción de una tabla de Hellman, se puede emplear el criptosistema \textit{data encryption standard} (DES), el cual toma textos de $P$ de 64 bits y los transforma en textos de $C$ de 64 bits, empleando una clave de $K$ de 56 bits, analizado más a fondo en~\cite{DES}. La operación de cifrado se puede representar de la siguiente forma:

\begin{center}
	\begin{equation}
		\tag{1}
		c = k(p)\;\;.
		\label{cifrado}
	\end{equation}
\end{center}

Para transformar $c$ en una posible clave de $K$ mediante el uso de la función $R$, se define la siguiente operación:

\begin{center}
	\begin{equation}
		\tag{2}
		f(k) = R[c]\;\;.
		\label{efe}
	\end{equation}
\end{center}

\subsection{Generación de una tabla}

Teniendo en cuenta todos estos parámetros, para formar una tabla de dimensiones $m \times t$, se realizará el mismo procedimiento para cada fila $i$ en el rango $1,~\dots, m$. Se comenzará tomando un punto de partida, el cual será una clave aleatoria del conjunto de claves $K$. A este punto inicial se le denominará $p_{i_0}$, al cual le será aplicado la función $f$. Una vez hecho esto, se habrá obtenido un nuevo punto en la tabla $p_{i_1}$, diferente a la anterior por requerimientos de la función de reducción $R$. Este proceso será repetido un total de $t$ veces en cada fila, generando por último un punto final $p_{i_t}$, llegando a obtener al final la tabla indicada de $m$ filas y $t$ columnas. Una representación visual de la generación de la tabla podría ser la siguiente:

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.25]{tabla.png}
    \caption{Computación esquematizada de las tablas de Hellman en su TMTO}
    \label{tabla}
\end{figure}

Una vez finalizado el proceso, no se almacenará la tabla en su totalidad, sino que tan sólo serán almacenadas la primera y última entradas de cada fila, formando una tupla. De tal forma, tomando el ejemplo anterior, se almacenarían las tuplas \{$p_{1_0}, p_{1_t}$\}, \{$p_{2_0}, p_{2_t}$\}, \{$p_{3_0}, p_{3_t}$\}, $~\dots$, \{$p_{m_0}, p_{m_t}$\}. Este almacenamiento se hace con el objetivo de ahorrar espacio en memoria.

\subsection{Empleando tablas para descifrar textos}

La tabla generada es empleada durante el ataque para averiguar la clave empleada en el cifrado. El primer paso es probar con el punto final de la primera fila, $p_{1_t}$ en el caso anterior. Si esta resulta ser la clave deseada el ataque concluye con éxito. De lo contrario, se vuelve a generar la fila para ver si la clave se encuentra en uno de los pasos intermedios. El hecho de poder volver a generar la fila es posible debido a que se ha guardado su punto inicial, y supone también un proceso rápido. Esto se repite para las demás filas mientras que no se encuentre la clave deseada.

En el caso de elegir una clave aleatoria, la probabilidad de encontrarla con éxito es igual a $\frac{mt}{N}$, requiriendo únicamente $t$ operaciones. Esto resulta mucho más eficiente que un ataque por fuerza bruta, el cual realizando tan sólo $t$ operaciones tiene una probabilidad de éxito igual a $\frac{t}{N}$.

%\subsection{Empleando tablas para la búsqueda de colisiones}

%A la hora de tratar de averiguar colisiones para la función \hash~atacada, con el objetivo de obtener una contraseña de forma ilegítima, se realizará el siguiente procedimiento. Habiendo obtenido un \hash~almacenado en el sistema, denominado $h$, el primer paso será compararlo con los \hashes~encontrados en las últimas columnas de la tabla, tras lo cual se pueden dar dos posibles situaciones, dependiendo de si $h$ colisiona con alguna de las últimas columnas:

%\begin{itemize}
%
%    \item \textbf{$h$ colisiona}: este caso puede darse si la contraseña correspondiente a $h$ se encuentra en la columna anterior de la tabla, o puede resultar en una falsa alarma. En ambos casos, como es conocida la fila en que ha aparecido $h$, se tomará su punto de inicio y desde él se repetirá el proceso de generación de la tabla, hasta llegar a la columna anterior a $h$, para la cual habrá de comprobarse si permite el acceso al sistema.
%    \begin{itemize}
%    
%        \item \textbf{Acceso permitido}: efectivamente, se ha obtenido con éxito una de las contraseñas almacenadas en el sistema.
%        
%        \item \textbf{Acceso denegado}: falsa alarma. Esto sucede debido a que un valor \hash~puede ser obtenido aplicando la función correspondiente a diferentes contraseñas, por lo cual finalmente no se ha obtenido una contraseña válida.
%        
%    \end{itemize}
%
%    \item \textbf{$h$ no colisiona}: en este caso, se aplicará la función de reconstrucción a $h$, seguida de la función \hash~empleada, obteniendo un nuevo \hash~$h'$, el cual vuelve a compararse con las últimas columnas de la tabla.
%    
%\end{itemize}


%Hablando del cual, el intercambio tiempo-memoria que tiene lugar aquí depende de los valores asignados tanto a $m$ como a $t$. Una posible forma de pensar en dichos valores es tener en cuenta el número posible de \hashes~distintos que puede generar la función resumen atacada. Sea este número denominado $N$, una aproximación lógica trataría de asegurar que $m$ y $t$ cumplan la siguiente relación: $m \times t = N$. Dentro de esta relación, podrían darse los casos extremos de $m = N, t = 1$, o el contrario, $m = 1, t = N$, aunque dichos casos estarían implementando un ataque más parecido a la fuerza bruta en lugar de hacer uso del TMTO. En la época en la que Hellman ideó esta aproximación, en lugar de emplear tan sólo una tabla con dimensiones $m \times t = N$ su método hacía uso de diversas tablas de menor dimensionalidad para reducir las limitaciones establecidas por la memoria del sistema.

\chapter{El ataque del arco iris} \label{ataque}

\section{Relación con trabajos anteriores}

Hasta ahora se han visto diferentes aproximaciones que forman una base fundamental para la búsqueda de colisiones en funciones resumen. Aunque dichas aproximaciones no son empleadas hoy en día, sirvieron como base para el desarrollo del ataque del arco iris, el cual consiguió mejorar las prestaciones de todo lo visto anteriormente, mediante el uso de una estructura de datos que hace uso de los mismos principios que aquellos vistos en la Figura \ref{tabla}, expandiendo sobre ellos y resultando en las conocidas como tablas del arco iris.

En 2003, Philippe Oechslin publicó el primer artículo en el cual aparecía el concepto de la tabla del arco iris \cite{rainbow}. Dicha tabla sigue la estructura vista en la Figura \ref{tabla}, introduciendo algunos cambios. Uno de esos cambios es un aumento del tamaño de la tabla, ya que las limitaciones en cuanto a la memoria para almacenar las tablas que se daban lugar cuando Hellman publicó su artículo no ocurren en este caso.

\section{Características de las tablas del arco iris}

La clave de este ataque reside en el uso de sus tablas, las cuales son capaces de representar mucha más información que las tablas que emplea Hellman. De hecho, el ataque llevado a cabo por Hellman requiere hacer uso de varias de sus tablas, mientras que si se pretende obtener los mismos resultados mediante tablas del arco iris únicamente haría falta emplear una de estas tablas. Las dimensiones de las tablas del arco iris dependerán, en principio, del número total de textos diferentes que puedan ser averiguados, lo cual dependerá de las características de dichos textos. Diferentes factores como el número de caracteres permitidos o el uso o no de diferentes dominios de caracteres (letras minúsculas y/o mayúsculas, números, símbolos$\, \dots$) juegan un papel fundamental para determinar las dimensiones de las tablas del arco iris. 

\subsection{Funciones de reconstrucción}

Las funciones de reconstrucción representan un aspecto fundamental en cualquier implementación del ataque del arco iris. En resumidas cuentas, estas funciones son capaces de transformar valores \hash~en palabras o mensajes válidos dentro del contexto de la implementación. El funcionamiento básico de estas funciones requiere dos aspectos principales, los cuales son la función resumen para la cual se buscan las colisiones y el conjunto de textos válidos empleados en el contexto del ataque. Este último aspecto variará dependiendo del ámbito en el que se aplique el ataque. Por ejemplo, un ataque a contraseñas permite únicamente palabras individuales, mientras que un ataque a un sistema de firma electrónica estará tratando con mensajes enteros. Para ejemplificar el comportamiento de una función de reconstrucción $R$, si se pretende atacar una función resumen $h$ que recibe textos $p$ sería como sigue:

\begin{center}
	\begin{equation}
		\tag{3}
		p_0~~ \xrightarrow{h}~~ h(p_0)~~ \xrightarrow{R}~~ p_1\;\;.
		\label{reconstrucción}
	\end{equation}
\end{center}

La característica más distinguida de las tablas del arco iris, y por la cual reciben su nombre, reside en el uso que son capaces de hacer de la función de reconstrucción, ya que es posible emplear diferentes funciones de reconstrucción en la misma tabla. Aunque esto no parezca tener demasiada importancia en un principio, en la práctica resulta ser un aspecto fundamental a la hora de obtener resultados de calidad, ya que estos variarán dependiendo de la función o funciones de reconstrucción empleadas. De esta manera, el foco de mayor importancia en cuanto a la construcción de tablas del arco iris se refiere pasa a ser la elección apropiada de una o varias funciones de reconstrucción, siendo el objetivo principal en este aspecto averiguar la configuración idónea de funciones de reconstrucción. 

El papel que juegan las funciones de reconstrucción en la creación de una tabla del arco iris es fundamental, ya que se asemejan a la función de reducción vista en el apartado \ref{params}.

\subsection{Generación de tablas del arco iris}

% Cambiar construcción de la tabla, con funciones hash, y explicar las colisiones internas de las tablas
%El método de construcción de las tablas del arco iris, como ya se ha dicho, sigue los mismos pasos de las tablas de Hellman, tomando una contraseñas inicial diferente para cada fila de la tabla, generando su valor \hash~y empleando la función de reconstrucción para obtener una nueva contraseña, así tantas veces como columnas tenga la tabla y para tantas filas como se requiera. Una vez generada una tabla del arco iris, será almacenada en memoria para su posterior uso. Dicho uso se llevará a cabo al igual que con las tablas de Hellman. La mejora en los resultados en este aspecto viene proporcionada por el aumento en las dimensiones de la tabla, aunque esto no es lo único que difiere en las tablas del arco iris.
%Teniendo en cuenta todos estos parámetros, para formar una tabla de dimensiones $m \times t$, se realizará el mismo procedimiento para cada fila $i$ en el rango $1,~\dots, m$. Se comenzará tomando una contraseña inicial del conjunto $P$, denominada $p_{i_0}$, de la cual será generado su valor \hash, el cual será reconstruido aplicándole la función $R$. Una vez hecho esto, se habrá obtenido una nueva contraseña $p_{i_1}$, diferente a la anterior por requerimientos de la función de reconstrucción $R$. Este proceso será repetido un total de $t$ veces en cada fila, generando por último el valor \hash~correspondiente a la última contraseña ($p_{i_m}$) obtenida por $R$, llegando a obtener al final la tabla indicada de $m$ filas y $t$ columnas. Si se denomina $f$ al proceso de aplicar a una contraseña una función \hash~seguida de una función de reconstrucción, una representación visual de la generación de la tabla podría ser el siguiente:\\
Antes de construir una tabla del arco iris, es necesario conocer la función resumen $h$ a atacar y el conjunto de textos válidos $P$ que pueden ser pasados a dicha función resumen. Una vez sabido esto, pretendiendo atacar una función resumen $h$ en búsqueda de colisiones se construirá una tabla del arco iris de $m$ filas y $t$ columnas. Para la construcción de dicha tabla el mismo procedimiento tendrá lugar para cada fila $i$ en el rango $1,~\dots, m$. Comenzando por un punto inicial $p_{i_0} \in P$, su valor \hash~será calculado, resultando en $h(p_{i_0})$. Tras obtener este valor, la función de reconstrucción lo tomará como entrada, produciendo un texto $p_{i_1} \in P$, el cual será distinto al texto anterior por requerimientos de la función de reconstrucción. Para cada fila $i$, este proceso se repetirá $t$ veces, generando por último el valor \hash~correspondiente al último texto $p_{i_t}$. Si se repite este procedimiento para $m$ filas, el resultado es una tabla del arco iris de dimensiones $m \times t$. Si se denomina $f$ al proceso de aplicar a un texto una función resumen seguida de una función de reconstrucción, una representación visual de la generación de la tabla sería la siguiente:

%\begin{center}
%	$p_{1_0}~~ \xrightarrow{~f~}~~ p_{1_1}~~ \xrightarrow{~f~}~~ \dots~~ \xrightarrow{~f~}~~ p_{1_t}~~ \xrightarrow{~h~}~~ h(p_{1_t})$ \\
%	~\\
%	$p_{2_0}~~ \xrightarrow{~f~}~~ p_{2_1}~~ \xrightarrow{~f~}~~ \dots~~ \xrightarrow{~f~}~~ p_{2_t}~~ \xrightarrow{~h~}~~ h(p_{2_t})$ \\
%	~\\
%	$p_{3_0}~~ \xrightarrow{~f~}~~ p_{3_1}~~ \xrightarrow{~f~}~~ \dots~~ \xrightarrow{~f~}~~ p_{3_t}~~ \xrightarrow{~h~}~~ h(p_{3_t})$ \\
%	$\vdots\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\vdots$ \\
%	~\\
%	$p_{m_0}~~ \xrightarrow{~f~}~~ p_{m_1}~~ \xrightarrow{~f~}~~ \dots~~ \xrightarrow{~f~}~~ p_{m_t}~~ \xrightarrow{~h~}~~ h(p_{m_t})$ \\
%\end{center}

\begin{figure}[H]
	\centering
	\includegraphics[scale = 0.20]{tabla_rainbow}
	\caption{Generación esquematizada de una tabla del arco iris}
	\label{tabla_rainbow_gen}
\end{figure}

La forma de almacenar estas tablas es la misma que la que empleaba Hellman en su TMTO, ya que se almacenará una tupla con el primer y el último elemento de cada fila, el lugar de la totalidad de la misma. De esta manera, las tuplas almacenadas en el ejemplo de la Figura \ref{tabla_rainbow_gen} serían \{$p_{1_0},~h(p_{1_t})$\}, \{$p_{2_0},~h(p_{2_t})$\}, \{$p_{3_0},~h(p_{3_t})$\}, $~\dots$, \{$p_{m_0},~h(p_{m_t})$\}.

Puede ocurrir también que durante el proceso de generación de la tabla se generen colisiones internas el las últimas columnas, es decir, que dos o más de las últimas columnas acaben teniendo el mismo valor \hash. Esto contribuye a reducir el número de filas únicas de la tabla, aunque si se consigue mantener por debajo de un porcentaje pequeño no debería de tener un impacto negativo significante en la mejora brindada por el TMTO.

Dicho TMTO ocurre en este caso dependiendo de los valores de $m$ y $t$ que se elijan para generar la tabla. Un mayor número de filas respecto al número de columnas supondrá un menor tiempo de computación para la generación de la tabla, pero requerirá a su vez más espacio en memoria para almacenar los resultados, ya que se obtendrán más tuplas con la primera y última entrada de cada fila. En cambio, aumentar el valor de $t$ mientras se reduce el de $m$ resultará en una reducción en el espacio requerido en memoria, aunque el tiempo de computación necesario para obtener la tabla será mayor, ya que para cada fila se repetirá en procedimiento visto en la Figura \ref{tabla_rainbow_gen} un mayor número de veces. 

\subsection{Búsqueda de colisiones mediante tablas del arco iris}

Encontrar el valor \hash~que se está buscando en una entrada de una tabla del arco iris significa que la entrada anterior contiene un texto que genera dicho \hash Teniendo disponible una tabla del arco iris, si se desea encontrar colisiones para una función resumen $h$ se sigue un proceso similar al visto en las tablas de Hellman. Mirando primero al segundo valor de la primera tupla, si esta valor \hash~coincide con el que se busca, se sabe entonces que la entrada anterior en la tabla contiene el texto que lo genera. De lo contrario, se genera la fila de nuevo, comprobando cada resumen generado hasta encontrar el valor \hash~buscado. Si esto no ocurre para esta fila se intenta con la siguiente, repitiendo el proceso hasta dar con la colisión.

\subsection{Escalabilidad}

%Otra de las ventajas del ataque del arco iris es su escalabilidad, ya que una correcta implementación del mismo puede servir para atacar diferentes funciones \hash~y dominios de contraseñas. Las diferencias corresponderán únicamente con los tiempos empleado en la generación de las tablas y la búsqueda de contraseñas. A su vez, cabe la posibilidad de requerir ajustar las funciones de reconstrucción a las diferentes funciones \hash, aunque siempre dependerá del objetivo que se pretenda conseguir al buscar colisiones de la función correspondiente.
Otra de las ventajas del ataque del arco iris respecto a otras implementaciones es su escalabilidad, la cual es observable mediante diferentes despliegues del ataque. En concreto, en la búsqueda de colisiones en funciones \hash, si se consigue implementar el ataque contra una función resumen que produce valores \hash~de $n$ bits, obteniendo unos resultados calificados como buenos, al cambiar la función resumen por una que genere valores \hash~de $2n$ bits, la calidad de los resultados apenas varía respecto a los anteriores. El único aspecto que se ve afectado será el tiempo empleado en llevar a cabo el ataque, el cual aumentará en contextos más complejos.

\section{Puntos distinguidos}\label{puntosdist}

Dentro de las posibilidades que ofrece el ataque del arco iris, existen también diferentes formas de llevarlo a cabo, siendo una variante muy popular el método de los puntos de control o puntos distinguidos, ideado por Rivest \cite{rivest}.

Tomando el método de Hellman \cite{hellman} mediante el uso del TMTO, Rivest implementó una mejora que reducía el tiempo de búsqueda a la hora de tratar de obtener contraseñas. Dicha mejora está basada en la implementación de puntos distinguidos en la tabla.

Los puntos distinguidos de Rivest se dan al establecer ciertas condiciones para las últimas entradas de la tabla, es decir, los elementos contenidos en las últimas columnas. Dichas condiciones quedan a la elección del atacante, pudiendo ser empezar o terminar con un número determinado de ceros o unos, por ejemplo. Esta aproximación tiene un matiz a la hora de generar la tabla, y es que como las últimas entradas deben cumplir las condiciones establecidas, ahora en lugar de obtener dichas entradas después de $t$ pasos, se habrá de continuar hasta generar una entrada que satisfaga dichas condiciones, lo cual puede darse en una entrada cercana a la inicial o puede tardar más de lo previsto en ocurrir. Por otra parte, la gran ventaja que brinda este método es una reducción significativa en cuanto al tiempo de búsqueda en las tablas, ya que el número de posibles colisiones de últimas entradas de la tabla se ve notablemente reducido, lo cual resulta también en un mayor rango de contraseñas cubierto por la tabla, aumentando la probabilidad de éxito de la misma.

\section{Contramedidas de una función \hash~para inutilizar el ataque del arco iris} \label{salt}

Aunque el ataque del arco iris tiene una efectividad muy alta cuando se implementa de la forma correcta, existen escenarios en los cuales resulta inviable implementar el ataque o directamente imposible, teniendo lugar mayormente cuando la función resumen la cual se pretende atacar hace uso de los siguientes métodos:

\begin{itemize}

    \item \textbf{\textit{Salting}}: la técnica conocida como \textit{salting} consiste en añadir una cadena aleatoria conocida como \textit{salt}, la cual no es secreta, a la contraseña antes de ser resumida, o directamente al valor \hash~resultante. Por ejemplo, si se partiera con la contraseña $p$, el \textit{salt} $s$ y la operación de concatenación $+$,~~sería posible obtener como valores \hash~ tanto $h = HASH(p+s)$ como $h = HASH(p)+s$. Para llevar a cabo el ataque del arco iris con éxito frente a funciones \hash~que hacen uso de esta técnica es necesario generar tablas del arco iris para cada \textit{salt} posible, lo cual para tamaños de \textit{salt} pequeños no supone un problema serio, pero en cuanto se alcanza cierto tamaño de \textit{salt} resulta inviable implementar el ataque debido a la enorme cantidad de tablas necesarias.
    
    \item \textbf{Estiramiento}: esta técnica hace uso del \textit{salting}, concatenándolo a la contraseña antes de generar el valor \hash~correspondiente. Tras obtener dicho \hash~se repite el mismo proceso un número de veces determinado, esta vez concatenando el \textit{salt} al valor \hash~antes obtenido. De esta forma, además de requerir tablas del arco iris para cada \textit{salt} posible, las tablas han de replicar el bucle de estiramiento, lo cual como es fácilmente observable puede resultar en la inviabilidad del ataque.
    
\end{itemize}

Cabe destacar que el \textit{salting} y el estiramiento ocurren por lo general en sistemas de almacenamiento de contraseñas protegidas por funciones resumen. En este contexto, la aparición de estas técnicas consiguió dejar prácticamente inútil al ataque del arco iris en este contexto, aunque incluso después de dicha aparición, los sistemas que no hacen uso del \textit{salting} o el estiramiento siguen siendo vulnerables a este ataque. Un ejemplo muy notorio pueden ser algunas versiones del sistema operativo \textit{Windows} de la empresa Microsoft, los cuales hasta el sistema \textit{Windows} 7 (incluido) han sido atacados con éxito por tablas del arco iris. De hecho, en su artículo original, Philippe Oechslin consigue con éxito romper el 100\% de las contraseñas almacenadas en los sistemas \textit{Windows} contra los que lanza su ataque \cite{rainbow}. Esto puede servir como muestra de la relevancia que llegó a alcanzar el ataque del arco iris.

\chapter{Experimentación}

Habiendo expuesto el funcionamiento del ataque del arco iris y sus características más destacadas a tener en cuenta para su implementación, es el momento de detallar el desarrollo llevado a cabo en este proyecto. Dicho desarrollo se centra en la búsqueda de colisiones para funciones resumen, con el objetivo de obtener una implementación capaz de encontrar dichas colisiones de una manera eficiente. Para representar la búsqueda de colisiones de una forma clara, se simulará un ataque a las contraseñas de acceso a un sistema operativo, siendo el objetivo tratar de averiguar el máximo número de contraseñas posibles.

En el uso de contraseñas de acceso a un sistema operativo, las contraseñas como tal no son almacenadas, sino sus valores \hash, generados por la función resumen elegida para protegerlas. De tal forma, cuando un usuario introduce su contraseña para acceder al sistema, se calcula su valor \hash~y, en caso de coincidir con el valor almacenado, se garantiza el acceso. De esta manera, cualquier función \hash~que no tenga resistencia contra colisiones, como se ha visto en el apartado \ref{props}, será vulnerable frente al ataque del arco iris. Esto es debido a que si se encuentra una colisión para el valor \hash~almacenado en el sistema, se consigue acceder a él de forma no autorizada. Este es un ejemplo de la gran variedad que existen para los cuales resulta de interés encontrar colisiones para funciones resumen.

En primer lugar, se han de determinar dos aspectos fundamentales para el correcto funcionamiento del ataque: el dominio de contraseñas a atacar y la función \hash~que tratará de protegerlas. Aunque en un primer momento parezcan elecciones débiles, existe un motivo de peso para que así sea. Este desarrollo servirá para representar una implementación base, la cual es perfectamente escalable a dominios de contraseñas mayores y funciones \hash~más complejas. En el caso de una correcta implementación, el único aspecto que se verá afectado de forma más significativa sería el tiempo requerido para llevar a cabo el ataque, así como la memoria necesaria para almacenar las tablas del arco iris, aunque la calidad de los resultados debería mantenerse extremadamente similar. De esta manera, debido a que será necesario experimentar con diversos tamaños de tabla y configuraciones de las mismas, los tiempos empleados y la memoria ocupada en disco en dicha experimentación serán mínimos, agilizando todo el proceso.

\section{Especificaciones}

\subsection{Dominio de contraseñas atacado}

Un dominio de contraseñas puede ser descrito como todo el rango de posibles contraseñas válidas. En este caso, serán aquellas contraseñas que pueden emplearse para acceder al sistema operativo. Los factores que determinan un dominio son, fundamentalmente, la longitud de las contraseñas y los caracteres permitidos. En la implementación aquí desarrollada, las contraseñas tendrán una longitud exacta de seis caracteres, los cuales únicamente podrán ser números. Como resultado, el número total de contraseñas es de un millón, las cuales se encuentran en el rango $'000000',~\dots, '999999'$.

%Dominio, CRC-32, escalabilidad

\subsection{Función resumen atacada} \label{crc32}

Para este proyecto se ha escogido atacar valores \hash~de contraseñas generados utilizando la función \hash~CRC-32. Las siglas CRC provienen de \textit{cyclic redundancy check}, o lo que es lo mismo verificación por redundancia cíclica, mientras que el número 32 indica que las cadenas de salida resultantes tienen una longitud fija de 32 bits. Esta función pertenece a la familia de las funciones CRC, el uso de las cuales es bastante popular debido a su fácil implementación y rapidez de computación, entre otras cosas.

Cabe destacar que son de sobra conocidas las debilidades que presenta esta función \hash~a la hora de ocultar contraseñas frente a ataques criptográficos como el ataque del arco iris. De tal forma, se presupone que se obtendrán resultados satisfactorios al implementar el ataque frente a esta función. Contra una función resumen que genere valores \hash~de mayor longitud o que emplee más caracteres además de números, la calidad de los resultados debería ser similar, debido a la escalabilidad del ataque del arco iris.

\section{Aproximación original}

%R1, explicar diagonal, cribado en esquina inferior izquierda
\subsection{Dimensiones de las tablas del arco iris}

Como se ha visto en el apartado anterior, el dominio de contraseñas a ser atacadas consta de un total de un millón de contraseñas, el cual va a pasar a ser representado por el parámetro $N$. Como también sucediera anteriormente en la sección \ref{tmto} al introducir el intercambio tiempo-memoria (TMTO), en la generación de tablas al implementar el ataque del arco iris se ha de tener en cuenta el tamaño de dichas tablas, el cual en este caso dependerá de el número total de contraseñas. Recuérdese que el tamaño de una tabla en el ataque del arco iris viene dado por el número de filas ($m$) y de columnas ($t$) que posee. Una de las mayores diferencias de este ataque respecto al TMTO de Hellman es que así como en el TMTO se hacía uso de diversas tablas de menor dimensión, en el ataque del arco iris basta con generar una sola tabla de mayor dimensionalidad. En este caso, el tamaño de la tabla debería de cumplir:

\begin{center}
    \begin{equation}
        \tag{Fórmula 1}
        m \times t \approx 10^6 = N
        \label{tamaño}
    \end{equation}
\end{center}

Teniendo esto en cuenta, se procederá a generar diferentes tablas de tamaños diversos, la mayoría cumpliendo con la relación establecida en la \ref{tamaño}, aunque algunas de las tablas tendrán tamaños por encima de $N$, para explorar más posibilidades y observar la eficiencia de las tablas con diferentes tamaños.

%\begin{itemize}

    %\item $m \in $\{250, 500, 1.000, 2.000, 2.500, 5.000, 10.000, 20.000, \\
    %25.000, 50.000, 100.000, 200.000, 250.000, 500.000, 1.000.000\}
    
    %\item $t \in $\{1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500, 1.000\}

	%\item $m \times t = $ \{1.000$\times$1.000, 2.000$\times$500, 2.500$\times$400, 5.000$\times$200, 10.000$\times$100\\
	%20.000$\times$50, 20.000$\times$100, 25.000$\times$40, 25.000$\times$100, 50.000$\times$20, 50.000$\times$50\}
    
%\end{itemize}

Aunque inicialmente existirán muchos tamaños de tabla, el objetivo será determinar a partir de qué tamaños se obtienen resultados calificados como buenos, para así poner el foco sobre aquellos tamaños para los cuales no se haya podido romper tantas contraseñas como se deseaba en un principio. De esta forma, se pretende averiguar los tamaños de tabla más eficientes que consigan encontrar el máximo número de colisiones para la función CRC-32. En este caso la eficiencia de una tabla viene medida en términos de memoria necesaria para su almacenamiento y tiempo requerido para su generación y búsqueda de contraseñas.

\subsection{Función de reconstrucción}

Queda todavía por especificar la función de reconstrucción a emplear. Cabe recordar que una función de reconstrucción toma como entrada una valor \hash, y produce como salida un texto válido del dominio empleado. En este caso, la función de reconstrucción producirá como salida una contraseña dentro del dominio $N$. Inicialmente la función de reconstrucción elegida, la cual pasará a denominarse \textbf{R1} desde este instante, actuaba de manera muy eficiente. Su comportamiento se ve a continuación, haciendo uso un valor \hash~$h$ y su correspondiente reconstrucción $r$:

\begin{itemize}

	\item tomando $h$ en forma numérica decimal, esta función le aplicará la operación módulo un millón, con el objetivo de obtener los seis últimos números de $h$. Partiendo desde una contraseña $p = $~'112233', y su correspondiente valor \hash~$h = $~'3570655599', la función de reconstrucción \textbf{R1} sigue el siguiente proceso:

		\begin{enumerate}

			\item Una vez obtenido el valor \hash~$h = $~'3570655599', se le aplicará la operación módulo un millón, con el objetivo de obtener los últimos seis dígitos del \hash.

			\item La reconstrucción resultante será $r = $~'655599', la cual pertenece al dominio de contraseñas $N$.

		\end{enumerate}

\end{itemize}

\subsection{Generación y uso de tablas del arco iris}

Una vez se ha especificado el dominio de contraseñas, la función \hash~a atacar y la función de reconstrucción a emplear, es momento de establecer el método de generación de las tablas del arco iris. Para ello, inicialmente será necesario elegir las dimensiones $m \times t$ de la tabla a generar, y posteriormente, como se ha visto en la Figura \ref{tabla_rainbow_gen}, una vez determinados los parámetros $m$ (filas) y $t$ (columnas), los pasos a seguir en este caso serán:

\begin{algorithm}[H]
	\caption{Algoritmo de generación de tablas del arco iris}
	\label{rainbow_alg}
	\begin{algorithmic}
		\REQUIRE tabla del arco iris vacía $rt$, número de filas $m$, número de columnas $t$, función resumen $H$, función de reconstrucción $R$
		\ENSURE tabla del arco iris $rt$ con dimensiones $m \times t$
		\STATE ~
		\STATE $i, j = 0$
		\WHILE{$i < m$}
			\STATE $p \leftarrow$ Contraseña inicial de la fila
			\STATE $h \leftarrow H(p)$
			\WHILE{$j < t$}
				\STATE $r \leftarrow R(h)$
				\STATE $h \leftarrow H(r)$
				\STATE $j \leftarrow j + 1$
			\ENDWHILE
			\STATE $i \leftarrow i + 1$
			\STATE $rt.append(\{p, h\})$
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

La tabla del arco iris resultante será almacenada en memoria, aunque no con todas las entradas generadas en su construcción. Mientras que el número de filas de cada tabla seguirá siendo $m$, el número de columnas se ve reducido, guardando tan sólo dos columnas por cada fila, las cuales corresponderán con la primera y la última columna de cada fila obtenidas durante la construcción de la tabla. No es necesario almacenar la tabla en su totalidad, ya que al emplear funciones de reconstrucción deterministas -es decir, que siempre generan el mismo resultado para cada entrada específica- únicamente se requiere saber desde qué contraseña inicial se ha partido en cada fila para volver a generarla en su totalidad siguiendo el proceso descrito en el algoritmo \ref{rainbow_alg}

Cabe destacar que las contraseñas iniciales para cada fila se obtendrán del dominio en orden ascendente. De esta manera, la contraseña inicial para la primera fila de la tabla siempre será $p_{1_0} = $'000000', mientras que la contraseña inicial para la segunda fila de la tabla será $p_{2_0} = $'000001', y así sucesivamente.

Recuérdese que se está tratando de averiguar colisiones para la función resumen atacada. Al elegir representar este ataque mediante un sistema del almacenamiento de contraseñas en forma de sus valores \hash, el éxito del ataque dependerá de la cantidad de contraseñas cuyos valores resumen son averiguados. A la hora de buscar colisiones en una tabla, antes que nada se buscará en las entradas guardadas en memoria, ya que si el valor \hash~se encuentra en una de las últimas entradas de la tabla no hay necesidad de volver a generarla, debido a que se puede concluir que es posible obtener su contraseña correspondiente, la cual se encontrará en la entrada anterior. En caso de no encontrar el valor \hash~en una de las últimas entradas de la tabla, se realizará el proceso de búsqueda volviendo a generar la tabla, ya que cabe la posibilidad de que el valor \hash~a romper se encuentre en una de las entradas entre la primera y la última, las cuales no han sido almacenadas en memoria. Si en algún momento durante esta búsqueda se da con el valor \hash~del cual se pretende encontrar una colisión, se concluye la búsqueda con éxito. El caso opuesto significará que la tabla no ha sido capaz de dar con la colisión deseada.

En cuanto a el tamaño de la tabla, puede observarse que cuantas más filas posea, mayor probabilidad existirá de romper una contraseña sin necesidad de generar la tabla de nuevo, mientras que cuantas más columnas tenga una tabla, generará un mayor número de posibles contraseñas en la búsqueda, por lo cual aumentará la probabilidad de romper una contraseña con éxito. Viendo estas propiedades, es muy tentador generar tablas del máximo tamaño posible, ya que en principio parece que parten con ventaja respecto a tablas más pequeñas. Bien, no todo son ventajas con un mayor tamaño, ya que si bien la probabilidad de éxito aumenta, también lo hace en principio el porcentaje de colisiones en una misma tabla. Una colisión se da cuando para filas diferentes de una tabla, el valor \hash~generado en la última entrada es el mismo, resultando en una reducción del número de contraseñas únicas cubiertas por la tabla. También en cuanto al tamaño, si bien en este caso es factible construir tablas que contengan todas las contraseñas, ya que son en total $N = 10^6$, en el momento en que se esté tratando con un dominio de contraseñas de mayor tamaño esta posibilidad queda eliminada, ya que sería inviable obtener dichas tablas debido al tiempo requerido en su construcción y/o la memoria requerida para almacenarlas. En este caso las tablas con un millón de entradas no tardan más de cinco minutos en ser generadas y ocupan un total de 22.0 MB en memoria, siendo perfectamente viables.

\subsection{La estructura de datos para representar la tabla}

Antes de proceder a las pruebas de este primer lote de tablas del arco iris, queda detallar el aspecto final de la implementación del ataque del arco iris. En cuanto han sido determinados todos los parámetros que configurarán las tablas del arco iris, únicamente falta elegir la estructura de datos que será empleada para representarlas, la cual queda a elección del atacante. A la hora de optar por una estructura de datos u otra, se ha de tener en cuenta, como ya ha sido mencionado anteriormente, que no se va a almacenar en memoria la tabla en su totalidad, es decir, todas las $m \times t$ entradas, sino que únicamente se almacenarán la primera y última entradas de cada fila de la tabla, o lo que es lo mismo, la primera y última columnas de cada fila. Dentro de todas las posibilidades lo ideal sería, una vez que se haya desarrollado el método de construcción de tablas, generar aquellas que se desee mediante diferentes estructuras de datos, para una vez obtenidas todas ellas comparar los tiempos necesarios en su construcción y en el acceso a las mismas, así como el espacio que ocupan en memoria. En el caso de la implementación aquí desarrollada, se compararon tablas del arco iris representadas mediante listas de tuplas y diccionarios. Cada una de estas estructuras de datos representa las tablas de la siguiente forma:

\begin{itemize}

    \item \textbf{Lista de tuplas}: Cada entrada de la lista corresponde a una fila de la tabla y contiene una tupla o pareja de elementos. El primero de estos elementos es la contraseña inicial de la fila correspondiente, mientras que el segundo elemento corresponde al valor \hash~obtenido en la última entrada de la fila correspondiente. De esta manera, empleando la Figura \ref{tabla} como ejemplo, la lista de tuplas que equivaldría a esta tabla del arco iris correspondería con la siguiente representación: [($p_{1_0}, h_{1_t}$),~($p_{2_0}, h_{2_t}$),~($p_{3_0}, h_{3_t}$), ~$\dots$,~($p_{m_0}, h_{m_t}$)].
    
    \item \textbf{Diccionario}: esta estructura de datos viene como anillo al dedo a la hora de representar tablas del arco iris, debido a su estructura interna siendo cada entrada compuesta de una clave y su valor correspondiente, tal que \textit{clave : valor}. De tal forma, en cada entrada del diccionario correspondiente a una fila de la tabla, la \textit{clave} será igual a la primera contraseña de dicha fila, mientras que el \textit{valor} corresponderá con el resumen \hash~generado en la última columna de dicha fila. De nuevo, si se toma como ejemplo la Figura \ref{tabla}, el diccionario resultante que representaría a la tabla del arco iris correspondiente sería el siguiente: \{$p_{1_0} : h_{1_t},~p_{2_0} : h_{2_t},~p_{3_0} : h_{3_t}, ~\dots,~p_{m_0} : h_{m_t}$\}.
    
\end{itemize}

Tras construir las primeras tablas del arco iris de diversos tamaños, habiendo generado dos copias de cada una, siendo una copia representada por una lista de tuplas y la otra por un diccionario, se experimentó con ellas midiendo los tiempos empleados en la generación y búsqueda, así como la memoria ocupada. Tras realizar dicha experimentación, se optó por elegir el diccionario como estructura de datos para todas las futuras tablas. Esto fue debido a que, si bien los tiempos requeridos por cada una de las estructuras de datos resultaron ser extremadamente similares, las tablas representadas por un diccionario ocupaban cerca de la mitad del espacio en memoria que aquellas de igual tamaño pero guardadas en forma de lista de tuplas.

Una vez establecido todo lo necesario para construir las tablas del arco iris, se puede proceder a su generación y almacenamiento en disco, para así tenerlas preparadas para llevar a cabo el ataque contra las contraseñas de acceso al sistema, las cuales hay que generar también.

\subsection{Generación de contraseñas de acceso como corpus de test} \label{contraseñas}

Para simular las contraseñas almacenadas en un sistema operativo en forma de valores \hash, se generarán un total de 1.000 valores \hash~aleatorios. Para su obtención se escogerá de forma aleatoria 1.000 contraseñas contenidas en el dominio establecido ($N$), generando el valor \hash~correspondiente de cada una y almacenándolo en una lista. Dicha lista será almacenada en disco al finalizar el proceso de obtención del los 1.000 valores \hash. Las contraseñas correspondientes a estos 1.000 \hashes~serán las que todas las tablas tratarán de romper, es decir, obtener la contraseña original únicamente conociendo el valor \hash~correspondiente.

\subsection{Primeras pruebas}\label{primeras pruebas}

Una vez generadas todas las tablas del arco iris y las contraseñas a atacar, es el momento de ponerse manos a la obra. A cada tabla empleada en el ataque del arco iris a las contraseñas se le asigna un porcentaje de éxito. Dicho porcentaje de éxito para cada tabla se mide dividiendo el número de colisiones que ha sido capaz de encontrar entre el número total de colisiones a averiguar, 1.000 en este caso. Para todos los resultados se empleará el mismo código de color indicando la calidad de los mismos:

\begin{itemize}

    \item \textcolor{red}{rojo}: porcentaje de éxito en el rango de 0,~$\dots$,~69'99\%.
    
    \item \textcolor{y}{amarillo}: porcentaje de éxito en el rango de 70,~$\dots$,~84'99\%.
    
    \item \textcolor{b}{azul}: porcentaje de éxito en el rango de 85,~$\dots$,~94'99\%.
    
    \item \textcolor{g}{verde}: porcentaje de éxito en el rango de 95,~$\dots$,~100\%.
    
\end{itemize}

Idealmente se desea que las tablas del arco iris generadas sean capaces de encontrar todas las colisiones, de esta forma adivinando todas las contraseñas almacenadas en el sistema. Si bien esto es posible en este caso para el dominio elegido, si se expandiese dicho dominio resultaría más complicado, por lo cual si una tabla consigue encontrar al menos 950 colisiones de las 1.000 generadas aleatoriamente será clasificada como idónea. Así mismo, una tabla que no llegue a descubrir tantas colisiones pero consiga al menos encontrar 850 será clasificada como aceptable, ya que significará que en la mayoría de los casos será capaz de acceder al sistema. Las tablas que no consigan llegar a ese nivel no serían válidas para ser empleadas en un ataque, aunque si al menos consiguen averiguar 700 colisiones puede considerarse que se han quedado cerca de ser aceptables, mientras que una tabla que ni siquiera consiga hacerse con 700 colisiones debería de ser descartada de inmediato, ya que tendría una probabilidad de encontrar una colisión similar a sacar cara o cruz tirando una moneda al aire.

%Justificar tamaños iniciales, cribado
Antes de pasar a los resultados obtenidos en esta primera tanda de pruebas, cabe recordar que las dimensiones de las tablas que se van a ver servirán para determinar en qué tamaños de tabla habrá que centrarse en la búsqueda de las tablas del arco iris más eficientes. La eficiencia en este caso interesa desde el punto de vista del tiempo empleado en la generación de la tabla y la búsqueda de colisiones, así como la memoria necesaria para almacenar dicha tabla en el sistema. 

Los resultados de la primera prueba pasan a verse a continuación, con las tablas que emplean la función de reconstrucción \textbf{R1}:

\def\arraystretch{1.5}
\begin{table}[H]
	\LARGE
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{13}{*}{$t$} & 1 & & & & & & & & & & & & & \textcolor{g}{100\%} \\ \cline{2-15}
		& 2 & & & & & & & & & & & & \textcolor{b}{91.9\%} & \\ \cline{2-15}
		& 4 & & & & & & & & & & & \textcolor{b}{90.6\%} & & \\ \cline{2-15}
		& 5 & & & & & & & & & & \textcolor{b}{90.6\%} & & & \\ \cline{2-15}
		& 10 & & & & & & & & & \textcolor{g}{95.2\%} & & & & \\ \cline{2-15}
		& 20 & & & & & & & & \textcolor{g}{96.1\%} & & & & & \\ \cline{2-15}
		& 40 & & & & & & & \textcolor{g}{97.1\%} & & & & & & \\ \cline{2-15}
		& 50 & & & & & & \textcolor{g}{97.4\%} &  & \textcolor{g}{99.3\%} & \textcolor{g}{99.6\%} & & \textcolor{g}{99.6\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 100 & & & & & \textcolor{g}{96.4\%} & \textcolor{g}{98.0\%} & \textcolor{g}{98.4\%} & \textcolor{g}{99.0\%} & \textcolor{g}{99.8\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 200 & & & & \textcolor{g}{95.2\%} & & & & & & & & & \\ \cline{2-15}
		& 400 & & & \textcolor{b}{91.8\%} & & & & & & & & & & \\ \cline{2-15}
		& 500 & & \textcolor{y}{84.1\%} & & & & & & & & & & & \\ \cline{2-15}
		& 1000 & \textcolor{r}{63.5\%} & & & & & & & & & & & & \\ \cline{2-15}
		& & 1000 & 2000 & 2500 & 5000 & 10000 & 20000 & 25000 & 50000 & 100000 & 200000 & 250000 & 500000 & 1000000 \\ \hline
		& & \multicolumn{13}{|c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas empleando \textbf{R1}}
	\label{resR1}
\end{table}

Puede observarse que se han obtenido resultados que se pueden calificar como buenas. Tan sólo una de las tablas sería descartada, aquella con dimensiones 1.000 $\times$ 1.000, mientras que después de esa solamente hay otra que no llega a ser aceptable, aunque se queda realmente cerca de conseguirlo. Todas las tablas con 2500 filas o más serán consideradas como aceptables o idóneas, llegando incluso a obtener un éxito del 100\% en varios casos, si bien dichas tablas tienen unas dimensiones que exceden el dominio elegido. Por ejemplo, la primera tabla que consigue un porcentaje de éxito perfecto tiene unas dimensiones de 250.000 $\times$ 100 = 25.000.000 $>$ 1.000.000 $= N$. Es interesante también observar como para las tablas con mayor número de filas, si se intenta mantener unas dimensiones dentro del dominio $N$ resultan peores que tablas con menos filas pero más profundidad. Por ejemplo, la tabla con dimensiones 200.000 $\times$ 5 tiene menor porcentaje de éxito que la tabla con dimensiones 20.000 $\times$ 50, teniendo un 10\% de las filas, pero 10 veces la profundidad, lo cual resulta clave para su mejor resultado.

Los resultados obtenidos pueden servir para confirmar que el desarrollo llevado a cabe de la implementación del ataque del arco iris ha sido correcto, ya que la mayoría de las tablas generadas brindan excelentes resultados. Aún así, resultaría interesante experimentar con una función de reconstrucción diferente, con el objetivo de mejorar los resultados.

\section{Una nueva función de reconstrucción}

Así como la función de reconstrucción empleada en la sección anterior (\textbf{R1}) actúa sobre el valor numérico decimal del valor \hash generado por la función CRC-32, esta nueva función de reconstrucción, la cual pasará a denominarse \textbf{R2}, actuará sobre el valor en hexadecimal del \hash, aunque también hace uso de su valor decimal. Al igual que ya se hizo con \textbf{R1}, a continuación se mostrará el comportamiento de la nueva función de reconstrucción \textbf{R2}, haciendo uso de una valor \hash~$h$ y su correspondiente reconstrucción $r$:

\begin{itemize}

	\item tomando $h$ en forma hexadecimal, esta función inicialmente, mientras $h$ tenga una longitud mayor a seis caracteres, se irá eliminando el primero de estos caracteres, hasta obtener una longitud igual a seis. Por último, todas las letras que queden en $h$ serán sustituidas por números. Estos números no serán seleccionados al azar, sino que corresponderán con los números de $h$ en forma decimal, comenzando desde el final, y tras cada sustitución se tomará el número anterior. Partiendo desde una contraseña $p =$~'112233', y su correspondiente valor \hash~hexadecimal $h =$~'D4D3E16F', la función de reconstrucción \textbf{R2} sigue el siguiente proceso:

		\begin{enumerate}
				
			\item Obtener primero los valores \hash~en forma numérica decimal~$h_{num} =$\\
			'3570655599' y en forma hexadecimal $h_{hex} =$~'D4D3E16F'

			\item Mientras la longitud de $h_{hex}$ sea mayor que seis, eliminar su primer carácter, resultando finalmente en $h_{hex} =$~'D3E16F'
		
			\item Recorrer los caracteres de $h_{hex}$ desde el principio, y aquellos que sean letras se reemplazan por números de $h_{num}$ comenzando por el final. Tras este paso se tendrá $r = '939165'$, ya que se habrán sustituido las letras 'D', 'E' y 'F' por los números $9, 9$ y $5$, los cuales se encuentran en la última, penúltima y antepenúltima posición de $h_{num}$, respectivamente.

		\end{enumerate}

\end{itemize}

Una vez especificado el comportamiento de esta nueva función de reconstrucción, de nuevo es momento de generar tablas del arco iris que hagan uso de ella, para tratar de atacar las mismas contraseñas que las tablas anteriores.

\subsection{Nuevos resultados}

En esta ocasión, el tamaño de las tablas generadas será el mismo que en el apartado \ref{primeras pruebas}, para así poder comprobar de manera sencilla la diferencia entre ambas implementaciones. Los resultados obtenidos con la función de reconstrucción \textbf{R2} son los siguientes:

\def\arraystretch{1.5}
\begin{table}[H]
	\LARGE
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{13}{*}{$t$} & 1 & & & & & & & & & & & & & \textcolor{g}{100\%} \\ \cline{2-15}
		& 2 & & & & & & & & & & & & \textcolor{b}{91.1\%} & \\ \cline{2-15}
		& 4 & & & & & & & & & & & \textcolor{b}{89.4\%} & & \\ \cline{2-15}
		& 5 & & & & & & & & & & \textcolor{b}{88.8\%} & & & \\ \cline{2-15}
		& 10 & & & & & & & & & \textcolor{b}{93.0\%} & & & & \\ \cline{2-15}
		& 20 & & & & & & & & \textcolor{g}{95.5\%} & & & & & \\ \cline{2-15}
		& 40 & & & & & & & \textcolor{g}{97.1\%} & & & & & & \\ \cline{2-15}
		& 50 & & & & & & \textcolor{g}{97.1\%} &  & \textcolor{g}{98.8\%} & \textcolor{g}{99.7\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 100 & & & & & \textcolor{g}{97.1\%} & \textcolor{g}{98.8\%} & \textcolor{g}{99.2\%} & \textcolor{g}{99.6\%} & \textcolor{g}{99.9\%} & & \textcolor{g}{99.9\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 200 & & & & \textcolor{b}{94.3\%} & & & & & & & & & \\ \cline{2-15}
		& 400 & & & \textcolor{y}{82.1\%} & & & & & & & & & & \\ \cline{2-15}
		& 500 & & \textcolor{y}{74.9\%} & & & & & & & & & & & \\ \cline{2-15}
		& 1000 & \textcolor{r}{57.1\%} & & & & & & & & & & & & \\ \cline{2-15}
		& & 1000 & 2000 & 2500 & 5000 & 10000 & 20000 & 25000 & 50000 & 100000 & 200000 & 250000 & 500000 & 1000000 \\ \hline
		& & \multicolumn{13}{|c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas empleando \textbf{R2}}
	\label{resR2}
\end{table}

Observando en un primer vistazo la distribución de los colores a lo largo de la tabla se puede apreciar que los resultados aquí obtenidos son peores que los anteriores en la tabla \ref{resR1} con la función de reconstrucción \textbf{R1}. La tabla del arco iris que ya se esperaba que fuera a ser descartada con $m =$ 1.000 rinde peor que antes, y se han generado menos tablas idóneas que en los resultados anteriores. De nuevo, las tablas con un número de entradas muy elevado siguen alcanzando el 100\% de porcentaje de éxito. Con todo esto siguen siendo resultados buenos, ya que hay múltiples tablas con un porcentaje de éxito mayor al 95\%.

Hasta ahora tan sólo se ha hecho uso de una función de reconstrucción tanto para la generación como para la búsqueda en las tablas del arco iris. Una vez visto esto, es el momento de tratar de combinar las funciones de reconstrucción con el objetivo de obtener mejores resultados, explotando esta característica fundamental de las tablas del arco iris.

\section{Combinando funciones de reconstrucción}

\subsection{Concatenación de funciones de reconstrucción}

Habiendo ya empleado ambas funciones de reconstrucción, \textbf{R1} y \textbf{R2}, la forma más intuitiva de combinarlas en una misma tabla del arco iris consiste en concatenar su uso. De esta manera, para cada fila de la tabla, para la primera entrada o columna la utilizará la función de reconstrucción \textbf{R1}, mientras que para la entrada siguiente se hará uso de la función \textbf{R2}, y así sucesivamente. Tomando como referencia la Figura \ref{tabla}, la construcción de cada fila de las tablas del arco iris configuradas con la concatenación de funciones de reconstrucción corresponderá con el siguiente esquema, para una columna $c$:

\begin{figure}[H]

	\centering

	$p_{1_c}~ \xrightarrow{CRC-32}~ h_{1_c}~ \xrightarrow{\textbf{R1}}~ r_{1_c}~ \xrightarrow{CRC-32}~ h_{2_c}~ \xrightarrow{\textbf{R2}}~ r_{2_c}~ \xrightarrow{CRC-32}~ h_{3_c}~ \xrightarrow{\textbf{R1}}~ r_{3_c} \dots$ \\

	\caption{Generación de una fila concatenando funciones de reconstrucción}
	\label{filaR1R2}
	 
\end{figure}

Este nuevo uso de las funciones de reconstrucción también afecta a la búsqueda de colisiones. En esta ocasión, al igual que anteriormente, si tras comparar el valor \hash~almacenado con las últimas columnas de la tabla no se ha conseguido encontrar una colisión, se deberá de generar la fila partiendo de su primera columna. En esta generación de la fila se aprecia la diferencia más significativa respecto a las tablas anteriores. En este caso, se comenzará generando la fila de igual manera que en la Figura \ref{filaR1R2}, buscando la colisión deseada. Si tras haber generado la fila al completo no se ha obtenido dicha colisión, en lugar de pasar a la siguiente fila, se volverá a generar la misma fila de nuevo, pero en esta ocasión empleando primero la función de reconstrucción \textbf{R2}, seguida de \textbf{R1} y concatenando como de costumbre hasta llegar al final de la fila. El motivo por el cual ocurre esto es debido a la combinación de ambas funciones de reconstrucción, ya que al tratar de encontrar una colisión determinada, se desconoce qué función de reconstrucción ha sido empleada previo a su obtención.

El rendimiento de estas tablas en la búsqueda de colisiones es el siguiente:

\def\arraystretch{1.5}
\begin{table}[H]
	\LARGE
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{13}{*}{$t$} & 1 & & & & & & & & & & & & & \textcolor{g}{100\%} \\ \cline{2-15}
		& 2 & & & & & & & & & & & & \textcolor{g}{97.0\%} & \\ \cline{2-15}
		& 4 & & & & & & & & & & & \textcolor{g}{96.2\%} & & \\ \cline{2-15}
		& 5 & & & & & & & & & & \textcolor{g}{97.0\%} & & & \\ \cline{2-15}
		& 10 & & & & & & & & & \textcolor{g}{98.3\%} & & & & \\ \cline{2-15}
		& 20 & & & & & & & & \textcolor{g}{99.5\%} & & & & & \\ \cline{2-15}
		& 40 & & & & & & & \textcolor{g}{99.7\%} & & & & & & \\ \cline{2-15}
		& 50 & & & & & & \textcolor{g}{99.6\%} &  & \textcolor{g}{100\%} & \textcolor{g}{100\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 100 & & & & & \textcolor{g}{99.9\%} & \textcolor{g}{99.9\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 200 & & & & \textcolor{g}{99.9\%} & & & & & & & & & \\ \cline{2-15}
		& 400 & & & \textcolor{g}{98.1\%} & & & & & & & & & & \\ \cline{2-15}
		& 500 & & \textcolor{g}{95.4\%} & & & & & & & & & & & \\ \cline{2-15}
		& 1000 & \textcolor{r}{63.1\%} & & & & & & & & & & & & \\ \cline{2-15}
		& & 1000 & 2000 & 2500 & 5000 & 10000 & 20000 & 25000 & 50000 & 100000 & 200000 & 250000 & 500000 & 1000000 \\ \hline
		& & \multicolumn{13}{|c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas empleando la concatenación de las funciones de reconstrucción}
	\label{resR1R2}
\end{table}

Estos son los mejores resultados obtenidos hasta el momento debido a que, aunque todavía existe la misma tabla descartable con 1.000 entradas, el resto de tablas del arco iris generadas son idóneas, habiendo obtenido incluso un mayor número de tablas que han conseguido encontrar todas las colisiones. Entrando en detalle en las tablas perfectas, además de las tablas más grandes de las cuales ya se esperaban estos resultados, se puede observar que la tabla con dimensiones 50.000$\times$50 es la de menor tamaño entre ellas, lo cual significa que sería la que menos memoria requiriese para ser almacenada. De esta tabla se podría decir también que sería, dentro de aquellas con un éxito del 100\%, una de las que menos tiempo requeriría en su generación, ya que si bien posee un número elevado de columnas, sus pocas filas en comparación a las demás reducirán el tiempo para construirla.

De esta manera ha quedado reflejada la utilidad de poder combinar diferentes funciones de reconstrucción en una misma tabla del arco iris. Teniendo en cuenta que esta combinación de ambas funciones de reconstrucción es la más simple que se puede emplear, resultaría interesante saber si una combinación más intrincada proporcionaría mejores resultados.

\subsection{Combinando las funciones de reconstrucción en un patrón}

Siguiendo el mismo comportamiento que la combinación anterior, surge una nueva con un ligero cambio. En esta ocasión, en lugar de concatenar ambas funciones, se establecerá un patrón cíclico, el cual seguirá el siguiente comportamiento: se empleará \textbf{R1} en la primera reconstrucción de cada fila, mientras que para las siguientes dos reconstrucciones se hará uso de \textbf{R2}. Acto seguido se volverá a usar \textbf{R1}, repitiendo este patrón hasta alcanzar el final la fila correspondiente. Tomando el esquema de la Figura \ref{filaR1R2}, haciendo uso de nuevo de una columna $c$, el método de generación de una fila para las tablas del arco iris que sigan esta configuración será el siguiente:

\begin{figure}[H]
	
	\centering

	$p_{1_c}~ \xrightarrow{CRC-32}~ h_{1_c}~ \xrightarrow{\textbf{R1}}~ r_{1_c}~ \xrightarrow{CRC-32}~ h_{2_c}~ \xrightarrow{\textbf{R2}}~ r_{2_c}~ \dots$ \\
	~\\
	$\dots~\xrightarrow{CRC-32}~ h_{3_c}~ \xrightarrow{\textbf{R2}}~ r_{3_c}~\xrightarrow{CRC-32}~ h_{4_c}~ \xrightarrow{\textbf{R1}}~ r_{4_c}~\dots$

	\caption{Generación de una fila combinando funciones de reconstrucción mediante un patrón reducido}
	\label{filapp}

\end{figure}

Al igual que ocurre con las tablas que concatenan ambas funciones de reconstrucción, las tablas que hagan uso de este patrón de funciones de reconstrucción también deberán variar su comportamiento en la búsqueda de colisiones. En esta ocasión, la primera vez que se genere una fila para buscar una colisión determinada, se empleará el patrón al igual que en la Figura \ref{filapp}. Si se genera la fila en su totalidad sin encontrar la colisión deseada, se construirá de nuevo con un desplazamiento en el patrón. En lugar de hacer uso del patrón \textbf{R1, R2, R2}, en esta segunda generación de la fila se comenzará empleando la función de reconstrucción \textbf{R2} para las dos primeras columnas, siendo la función \textbf{R1} empleada para la tercera columna, repitiendo este patrón hasta alcanzar el final de la fila. Si de nuevo no se ha encontrado la colisión buscada, se construirá la fila por vez final, esta vez empleando el patrón \textbf{R2, R1, R2}. El motivo por el cual la búsqueda se desarrolla de esta manera es el mismo que en el caso de las tablas que concatenan ambas funciones, para compensar el hecho de que se desconoce qué función de reconstrucción se utilizó en el paso anterior a obtener la colisión, en el caso de que esta exista en la tabla.

El ataque del arco iris llevado a cabo con las tablas que hacen uso de este patrón de reconstrucción obtienen los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\LARGE
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{13}{*}{$t$} & 1 & & & & & & & & & & & & & \textcolor{g}{100\%} \\ \cline{2-15}
		& 2 & & & & & & & & & & & & \textcolor{g}{98.1\%} & \\ \cline{2-15}
		& 4 & & & & & & & & & & & \textcolor{g}{98.9\%} & & \\ \cline{2-15}
		& 5 & & & & & & & & & & \textcolor{g}{99.4\%} & & & \\ \cline{2-15}
		& 10 & & & & & & & & & \textcolor{g}{99.8\%} & & & & \\ \cline{2-15}
		& 20 & & & & & & & & \textcolor{g}{100\%} & & & & & \\ \cline{2-15}
		& 40 & & & & & & & \textcolor{g}{100\%} & & & & & & \\ \cline{2-15}
		& 50 & & & & & & \textcolor{g}{100\%} &  & \textcolor{g}{100\%} & \textcolor{g}{100\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 100 & & & & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 200 & & & & \textcolor{g}{100\%} & & & & & & & & & \\ \cline{2-15}
		& 400 & & & \textcolor{g}{99.5\%} & & & & & & & & & & \\ \cline{2-15}
		& 500 & & \textcolor{g}{99.3\%} & & & & & & & & & & & \\ \cline{2-15}
		& 1000 & \textcolor{y}{80.5\%} & & & & & & & & & & & & \\ \cline{2-15}
		& & 1000 & 2000 & 2500 & 5000 & 10000 & 20000 & 25000 & 50000 & 100000 & 200000 & 250000 & 500000 & 1000000 \\ \hline
		& & \multicolumn{13}{|c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas empleando el patrón reducido}
	\label{respp}
\end{table}

Los resultados obtenidos han conseguido superar a los de la concatenación de funciones de reconstrucción, en la Tabla \ref{resR1R2}. Por primera vez no se han generado tablas que vayan a ser descartadas. Incluso la tabla que habitualmente tiene el peor rendimiento ($m =$ 1.000) en esta ocasión ha quedado significativamente cerca de ser considerada aceptable. La mejora de los resultados es debida a la mayor complejidad de este patrón con respecto a la concatenación de funciones. Existen muchas más tablas que han conseguido encontrar todas las colisiones, y si se comparan todas las tablas respecto a los resultados anteriores, se puede apreciar que cada una de ellas rinde mejor en este caso. En definitiva, el nuevo patrón ha proporcionado la mejora que se esperaba.

Tras observar estos resultados, cabe la posibilidad de mejora, la cual podría darse tratando de seguir el mismo esquema que el patrón empleado, aunque, al igual que se ha hecho en este patrón respecto a la concatenación de funciones de reconstrucción, será necesario un aumento en la complejidad del mismo.

\subsection{Un patrón más extenso}

En esta ocasión se va a emplear un método similar al anteriormente expuesto, aunque se va a complicar un poco más. En lugar de emplear un patrón que se repite cada tres pasos, la longitud del mismo casi se triplicará. Al igual que en el anterior patrón, se comenzará empleado \textbf{R1} para la primera entrada, mientras que para las siguientes dos entradas se hará uso de la función de reconstrucción \textbf{R2}. Tras estos tres primeros pasos, los dos siguientes emplearán la función de reconstrucción \textbf{R1}. Por último, para los tres pasos finales se utiliza de nuevo \textbf{R2}. De nuevo, para una columna $c$ de la tabla, el método de generación de una fila corresponderá con el siguiente esquema:

\begin{figure}[H]
	
	\centering

	$p_{1_c}~ \xrightarrow{CRC-32}~ h_{1_c}~ \xrightarrow{\textbf{R1}}~ r_{1_c}~ \xrightarrow{CRC-32}~ h_{2_c}~ \xrightarrow{\textbf{R2}}~ r_{2_c}~ \xrightarrow{CRC-32}~ h_{3_c}~ \xrightarrow{\textbf{R2}}~ r_{3_c} \dots$ \\
	~\\
	$\dots \xrightarrow{CRC-32}~ h_{4_c}~ \xrightarrow{\textbf{R1}}~ r_{4_c}~ \xrightarrow{CRC-32}~ h_{5_c}~ \xrightarrow{\textbf{R1}}~ r_{5_c}~ \xrightarrow{CRC-32}~ h_{6_c}~ \xrightarrow{\textbf{R2}}~ r_{6_c} \dots$ \\
	~\\
	$\dots \xrightarrow{CRC-32}~ h_{7_c}~ \xrightarrow{\textbf{R2}}~ r_{7_c}~ \xrightarrow{CRC-32}~ h_{8_c}~ \xrightarrow{\textbf{R2}}~ r_{8_c}~ \xrightarrow{CRC-32}~ h_{9_c}~\xrightarrow{\textbf{R1}}~ \dots$\;\;\;\; \\

	\caption{Generación de una fila combinando funciones de reconstrucción mediante un patrón extenso}
	\label{filaPG}

\end{figure}

De nuevo, la búsqueda de colisiones empleando las tablas del arco iris que hacen uso de este patrón de funciones de reconstrucción seguirá el mismo comportamiento que las tablas que emplean el patrón reducido del apartado anterior. En esta ocasión, como el patrón a utilizar tiene un ciclo de ocho pasos, cada fila será construida empleando el patrón inicial, seguido de los siete desplazamientos posibles en el caso de no dar con la colisión buscada.

Los resultados tras aplicar el ataque del arco iris con las tablas que hacen uso de esta configuración son los siguientes:

\def\arraystretch{1.5}
\begin{table}[H]
	\LARGE
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{13}{*}{$t$} & 1 & & & & & & & & & & & & & \textcolor{g}{100\%} \\ \cline{2-15}
		& 2 & & & & & & & & & & & & \textcolor{g}{98.5\%} & \\ \cline{2-15}
		& 4 & & & & & & & & & & & \textcolor{g}{99.9\%} & & \\ \cline{2-15}
		& 5 & & & & & & & & & & \textcolor{g}{100\%} & & & \\ \cline{2-15}
		& 10 & & & & & & & & & \textcolor{g}{100\%} & & & & \\ \cline{2-15}
		& 20 & & & & & & & & \textcolor{g}{100\%} & & & & & \\ \cline{2-15}
		& 40 & & & & & & & \textcolor{g}{100\%} & & & & & & \\ \cline{2-15}
		& 50 & & & & & & \textcolor{g}{100\%} &  & \textcolor{g}{100\%} & \textcolor{g}{100\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 100 & & & & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-15}
		& 200 & & & & \textcolor{g}{100\%} & & & & & & & & & \\ \cline{2-15}
		& 400 & & & \textcolor{g}{100\%} & & & & & & & & & & \\ \cline{2-15}
		& 500 & & \textcolor{g}{100\%} & & & & & & & & & & & \\ \cline{2-15}
		& 1000 & \textcolor{r}{63.0\%} & & & & & & & & & & & & \\ \cline{2-15}
		& & 1000 & 2000 & 2500 & 5000 & 10000 & 20000 & 25000 & 50000 & 100000 & 200000 & 250000 & 500000 & 1000000 \\ \hline
		& & \multicolumn{13}{|c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas empleando el patrón extenso}
	\label{resPG}
\end{table}

Estos resultados han conseguido mejorar respecto a todos los vistos con anterioridad, lo cual ya se esperaba en principio. El único empeoramiento comparando con los resultados obtenidos por las tablas que emplean el patrón reducido ocurre en la tabla de dimensiones 1.000 $\times$ 1.000. Todas las tablas restantes rinden mejor. De hecho, tan sólo se han generado tres tablas que no consiguen encontrar todas las colisiones buscadas. Para la primera de ellas, esto se debe al reducido número de filas que posee, ya que no consigue compensar aún teniendo la mayor profundidad de todas las tablas. Para las otras dos tablas que no han sido capaces de encontrar todas las colisiones hace falta observar si número de columnas. Esto justifica su rendimiento, ya que al poseer una profundidad tan reducida el patrón extenso no puede ser ejecutado en su totalidad. Aún con todo, estas tablas consiguen hacerse con una buena cantidad de colisiones.

\section{En busca de las tablas más eficientes} \label{config perf}

Tras la primera tanda de pruebas es fácilmente observable que, para tablas que superen las 10.000 filas, el porcentaje de éxito no baja del 88.0\%. Dichas tablas serán capaces de encontrar la mayoría de las colisiones buscadas, las cuales están representadas por los valores \hash~de las contraseñas almacenadas en el sistema. Si bien la intención del ataque del arco iris es dar con el mayor número de colisiones posible, resultaría interesante indagar en tablas de menor tamaño, para así poder determinar si realmente es necesario crear tablas que contengan tantas entradas, o si por el contrario existen ciertas configuraciones que son capaces de brindar resultados igual de buenos que las tablas más grandes. Encontrar dichas configuraciones es de gran interés, ya que de ser posible conseguirlo significaría una reducción en los requerimientos tanto de tiempo como de memoria, algo que siempre es beneficioso en este tipo de ataques.

\subsection{Nuevos tamaños} \label{nuevos_tamaños}

Si bien en las pruebas anteriores la tabla con el menor número de filas poseía $m =$ 1.000 filas, en la búsqueda de las tablas con resultados similares a los mejores obtenidos anteriormente pero con menor tamaño será necesario emplear tamaños de tabla diferentes, expandiendo la búsqueda con tamaños menores a los vistos anteriormente. De tal forma, la tabla con menos filas pasará a tener $m = 250$, mientras que la tabla más grande tendrá $m =$ 10.000 filas. En concreto, se generarán tantas tablas como posibles permutaciones existan de los siguientes conjuntos de $m$ y $t$:
\\
\begin{itemize}

    \item $m \in$ \{250, 500, 750, 1.000, 1.500, 2.000, 2.500, 5.000, 10.000\}
    
    \item $t \in$ \{50, 100, 200, 400, 500, 1.000\}
    
\end{itemize}

\subsection{Colisiones internas de las nuevas tablas}

En total se generarán $9 \cdot 6 = 54$ tablas para cada combinación de funciones de reconstrucción. Tras generar todas estas tablas, pero antes de obtener su rendimiento, resulta de interés observar las colisiones internas que aparecen en dichas tablas para las diferentes combinaciones de funciones de reconstrucción. Para ello se obtendrá el porcentaje de colisiones internas de cada tabla, obteniendo primero el número de colisiones internas recorriendo sus últimas columnas, determinando cuántos de sus valores no se repiten y asignando esa cantidad a un valor $c$, para seguidamente restarlo al número total de filas de la tabla ($m$), siendo el resultado de esta operación el número de colisiones internas que ocurren en la tabla. Acto seguido dicho número de colisiones internas $c$ será dividido entre el número de filas de la tabla $m$, dando como resultado el porcentaje de colisiones internas de la tabla respecto a su número de filas. Para dichos porcentajes, al igual que se ha hecho anteriormente con los porcentajes de éxito, se empleará un código de color, el cual será el siguiente:

\begin{itemize}

    \item \textcolor{red}{rojo}: porcentaje de colisiones en el rango de 70,~$\dots$, 100\%.
    
    \item \textcolor{y}{amarillo}: porcentaje de colisiones en el rango de 50,~$\dots$, 69'99\%.
    
    \item \textcolor{b}{azul}: porcentaje de colisiones en el rango de 25,~$\dots$, 49'99\%.

    \item \textcolor{g}{verde}: porcentaje de colisiones en el rango de 0,~$\dots$, 24'99\%.
    
\end{itemize}

Siempre que se hable de colisiones dentro de una tabla del arco iris se estará haciendo referencia a sus colisiones internas, mientras que cuando se esté hablando de las colisiones encontradas por una tabla siempre será relacionado con el proceso de búsqueda de colisiones de la función resumen atacada.

Interpretando el código de color anterior, podría decirse que una tabla que tenga colisiones internas en un 70 por ciento de sus filas o más no serían las más ideales para ser empleadas en la búsqueda de colisiones para una función \hash, ya que tantas colisiones internas se traducen en una reducción muy significante de las colisiones de la función resumen cubiertas por esa tabla. Si este porcentaje se reduce un poco, mientras una tabla cubra cerca de la mitad de las colisiones de valores \hash~que se le presuponen, serán sus dimensiones las que determinen su utilidad, ya que si la tabla es lo suficientemente grande será capaz de compensar la pérdida de colisiones cubiertas con su tamaño. Cualquier tabla que cubra más de la mitad de las colisiones supuestas por su tamaño será aceptable en este aspecto, aunque de nuevo sus dimensiones serán cruciales para determinar su efectividad atacando contraseñas. Por último, todas aquellas tablas que cubran tres cuartas partes o más de las colisiones que debería serán en principio las más efectivas.

Comenzando al igual que antes por las tablas que tan sólo emplean la reconstrucción con la operación módulo un millón (\textbf{R1}), se obtiene:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{g}{0.80\%} & \textcolor{g}{1.80\%} & \textcolor{g}{2.40\%} & \textcolor{g}{2.60\%} & \textcolor{g}{4.27\%} & \textcolor{g}{5.15\%} & \textcolor{g}{5.80\%} & \textcolor{g}{10.16\%} & \textcolor{g}{19.08\%} \\ \cline{2-11}
		& 100 & \textcolor{g}{2.00\%} & \textcolor{g}{2.60\%} & \textcolor{g}{4.00\%} & \textcolor{g}{5.00\%} & \textcolor{g}{7.47\%} & \textcolor{g}{9.55\%} & \textcolor{g}{10.76\%} & \textcolor{g}{18.96\%} & \textcolor{b}{32.75\%} \\ \cline{2-11}
		& 200 & \textcolor{g}{3.60\%} & \textcolor{g}{4.60\%} & \textcolor{g}{6.80\%} & \textcolor{g}{8.90\%} & \textcolor{g}{13.00\%} & \textcolor{g}{16.00\%} & \textcolor{g}{17.92\%} & \textcolor{b}{30.60\%} & \textcolor{b}{47.18\%} \\ \cline{2-11}
		& 400 & \textcolor{g}{5.20\%} & \textcolor{g}{8.40\%} & \textcolor{g}{13.07\%} & \textcolor{g}{16.50\%} & \textcolor{g}{23.47\%} & \textcolor{b}{28.55\%} & \textcolor{b}{31.96\%} & \textcolor{b}{48.74\%} & \textcolor{y}{65.83\%} \\ \cline{2-11}
		& 500 & \textcolor{g}{6.00\%} & \textcolor{g}{10.00\%} & \textcolor{g}{15.20\%} & \textcolor{g}{19.40\%} & \textcolor{b}{27.00\%} & \textcolor{b}{32.55\%} & \textcolor{b}{36.68\%} & \textcolor{y}{54.74\%} & \textcolor{r}{71.14\%} \\ \cline{2-11}
		& 1000 & \textcolor{g}{9.20\%} & \textcolor{g}{13.60\%} & \textcolor{g}{18.93\%} & \textcolor{g}{24.00\%} & \textcolor{b}{33.20\%} & \textcolor{b}{40.35\%} & \textcolor{b}{45.68\%} & \textcolor{y}{65.02\%} & \textcolor{r}{79.64\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de colisiones para las tablas empleando \textbf{R1}}
	\label{colR1}
\end{table}

Como era de esperar y va a ser habitual en estos resultados, las tablas con menos filas tendrán porcentajes de colisiones internas menores respecto a las tablas de mayor tamaño. Las únicas tablas con un porcentaje de colisiones internas muy restrictivo ocurren con unas dimensiones superiores al dominio $N$, lo cual no es sorprendente en tales casos. Se puede concluir que es uso exclusivo de \textbf{R1}, en cuanto a colisiones internas se refiere, parece prometer resultados de buena calidad a la hora de atacar las contraseñas.

Para las tablas que emplean únicamente la función de reconstrucción utilizando el \hash~en hexadecimal (\textbf{R2}) se obtienen los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{g}{0.00\%} & \textcolor{g}{1.60\%} & \textcolor{g}{2.00\%} & \textcolor{g}{2.60\%} & \textcolor{g}{4.20\%} & \textcolor{g}{5.70\%} & \textcolor{g}{6.64\%} & \textcolor{g}{12.52\%} & \textcolor{g}{22.60\%} \\ \cline{2-11}
		& 100 & \textcolor{g}{0.40\%} & \textcolor{g}{2.60\%} & \textcolor{g}{4.27\%} & \textcolor{g}{5.50\%} & \textcolor{g}{8.13\%} & \textcolor{g}{10.15\%} & \textcolor{g}{12.32\%} & \textcolor{g}{22.50\%} & \textcolor{b}{36.42\%} \\ \cline{2-11}
		& 200 & \textcolor{g}{2.80\%} & \textcolor{g}{7.20\%} & \textcolor{g}{9.47\%} & \textcolor{g}{12.40\%} & \textcolor{g}{16.27\%} & \textcolor{g}{18.80\%} & \textcolor{g}{21.60\%} & \textcolor{b}{34.72\%} & \textcolor{y}{51.27\%} \\ \cline{2-11}
		& 400 & \textcolor{g}{11.60\%} & \textcolor{g}{18.00\%} & \textcolor{g}{21.73\%} & \textcolor{b}{27.10\%} & \textcolor{b}{34.13\%} & \textcolor{b}{38.75\%} & \textcolor{b}{43.28\%} & \textcolor{y}{58.74\%} & \textcolor{r}{73.00\%} \\ \cline{2-11}
		& 500 & \textcolor{g}{15.60\%} & \textcolor{g}{23.60\%} & \textcolor{b}{27.60\%} & \textcolor{b}{33.40\%} & \textcolor{b}{41.07\%} & \textcolor{b}{46.50\%} & \textcolor{y}{51.68\%} & \textcolor{y}{67.52\%} & \textcolor{r}{79.88\%} \\ \cline{2-11}
		& 1000 & \textcolor{g}{18.00\%} & \textcolor{b}{28.80\%} & \textcolor{b}{35.87\%} & \textcolor{b}{42.80\%} & \textcolor{y}{53.67\%} & \textcolor{y}{60.95\%} & \textcolor{y}{66.76\%} & \textcolor{r}{81.62\%} & \textcolor{r}{90.47\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de colisiones para las tablas empleando \textbf{R2}}
	\label{colR2}
\end{table}

En esta ocasión, aunque para las tablas de menor tamaño se obtiene un menor número de colisiones internas, en cuanto aumentan las dimensiones de las tablas los resultados empeoran respecto a los anteriores. Esta es la razón por la cual, como se ha visto en las primeras pruebas, estas tablas tienen un peor rendimiento que las que emplean únicamente \textbf{R1}, aunque aún así seguían siendo buenos resultados. En este caso se han generado más tablas con peores porcentajes de colisiones internas, la más grande de ellas superando el 90 por ciento de las mismas, lo que se traduce en menos de 1.000 contraseñas cubiertas por una tabla que en principio se esperaba que cubriese 10.000. También hay más tablas por encima del cincuenta por ciento, cubriendo algo menos de la mitad de las contraseñas previstas, lo cual considerando su tamaño puede llegar a comprometer su rendimiento de manera significativa.

Pasando ahora a las tablas que combinan ambas funciones de reconstrucción se obtiene:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{g}{0.80\%} & \textcolor{g}{1.00\%} & \textcolor{g}{1.73\%} & \textcolor{g}{2.30\%} & \textcolor{g}{3.93\%} & \textcolor{g}{5.30\%} & \textcolor{g}{6.32\%} & \textcolor{g}{11.48\%} & \textcolor{g}{20.74\%} \\ \cline{2-11}
		& 100 & \textcolor{g}{0.80\%} & \textcolor{g}{1.60\%} & \textcolor{g}{3.07\%} & \textcolor{g}{4.30\%} & \textcolor{g}{6.80\%} & \textcolor{g}{8.80\%} & \textcolor{g}{10.96\%} & \textcolor{g}{19.48\%} & \textcolor{b}{33.78\%} \\ \cline{2-11}
		& 200 & \textcolor{g}{2.00\%} & \textcolor{g}{4.80\%} & \textcolor{g}{6.67\%} & \textcolor{g}{8.30\%} & \textcolor{g}{12.60\%} & \textcolor{g}{16.65\%} & \textcolor{g}{20.00\%} & \textcolor{b}{32.16\%} & \textcolor{b}{49.08\%} \\ \cline{2-11}
		& 400 & \textcolor{g}{2.40\%} & \textcolor{g}{9.00\%} & \textcolor{g}{12.80\%} & \textcolor{g}{17.80\%} & \textcolor{g}{23.00\%} & \textcolor{b}{29.05\%} & \textcolor{b}{33.24\%} & \textcolor{b}{47.44\%} & \textcolor{y}{63.71\%} \\ \cline{2-11}
		& 500 & \textcolor{g}{3.20\%} & \textcolor{g}{11.00\%} & \textcolor{g}{16.13\%} & \textcolor{g}{21.80\%} & \textcolor{b}{27.33\%} & \textcolor{b}{33.60\%} & \textcolor{b}{38.24\%} & \textcolor{y}{52.96\%} & \textcolor{y}{68.54\%} \\ \cline{2-11}
		& 1000 & \textcolor{g}{9.60\%} & \textcolor{g}{21.40\%} & \textcolor{b}{29.20\%} & \textcolor{b}{36.90\%} & \textcolor{b}{46.00\%} & \textcolor{y}{53.40\%} & \textcolor{y}{59.24\%} & \textcolor{r}{74.32\%} & \textcolor{r}{85.00\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de colisiones para las tablas empleando la concatenación de las funciones de reconstrucción}
	\label{colR1R2}
\end{table}

Aunque se ha mejorado respecto a las tablas que emplean únicamente \textbf{R2}, en comparación a las primeras tablas que hacen uso tan sólo de \textbf{R1} existen más colisiones internas en estas tablas, aunque en general estos resultados no son mucho peores. Este pequeño empeoramiento resulta sorprendente, ya que se esperaba que al combinar ambas funciones de reconstrucción el porcentaje de colisiones internas fuera reducido drásticamente. En línea con lo anteriormente visto siguen tanto la distribución de colores a lo largo de la tabla como los altos porcentajes de las tablas de mayor tamaño. Aún con todo, estos resultados se podrían clasificar como buenos en este contexto.

Para las tablas que emplean el denominado patrón reducido (\textbf{R1 + R2 + R2}) se generan los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{g}{0.80\%} & \textcolor{g}{0.60\%} & \textcolor{g}{0.80\%} & \textcolor{g}{1.10\%} & \textcolor{g}{1.73\%} & \textcolor{g}{2.00\%} & \textcolor{g}{2.68\%} & \textcolor{g}{4.86\%} & \textcolor{g}{9.30\%} \\ \cline{2-11}
		& 100 & \textcolor{g}{1.20\%} & \textcolor{g}{1.40\%} & \textcolor{g}{2.13\%} & \textcolor{g}{2.70\%} & \textcolor{g}{3.53\%} & \textcolor{g}{4.35\%} & \textcolor{g}{5.56\%} & \textcolor{g}{9.08\%} & \textcolor{g}{16.16\%} \\ \cline{2-11}
		& 200 & \textcolor{g}{1.60\%} & \textcolor{g}{2.00\%} & \textcolor{g}{2.80\%} & \textcolor{g}{3.80\%} & \textcolor{g}{5.40\%} & \textcolor{g}{6.75\%} & \textcolor{g}{8.44\%} & \textcolor{g}{14.32\%} & \textcolor{b}{25.46\%} \\ \cline{2-11}
		& 400 & \textcolor{g}{2.00\%} & \textcolor{g}{4.00\%} & \textcolor{g}{5.07\%} & \textcolor{g}{6.70\%} & \textcolor{g}{9.87\%} & \textcolor{g}{12.70\%} & \textcolor{g}{15.44\%} & \textcolor{g}{24.70\%} & \textcolor{b}{39.64\%} \\ \cline{2-11}
		& 500 & \textcolor{g}{1.60\%} & \textcolor{g}{3.80\%} & \textcolor{g}{5.73\%} & \textcolor{g}{7.40\%} & \textcolor{g}{11.47\%} & \textcolor{g}{14.65\%} & \textcolor{g}{17.80\%} & \textcolor{b}{29.54\%} & \textcolor{b}{45.17\%} \\ \cline{2-11}
		& 1000 & \textcolor{g}{5.60\%} & \textcolor{g}{11.80\%} & \textcolor{g}{16.13\%} & \textcolor{g}{18.90\%} & \textcolor{b}{25.87\%} & \textcolor{b}{30.75\%} & \textcolor{b}{35.08\%} & \textcolor{y}{51.08\%} & \textcolor{y}{67.09\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de colisiones para las tablas empleando el patrón reducido}
	\label{colpp}
\end{table}

Los resultados recién obtenidos son los mejores en cuanto al porcentaje de colisiones internas se refiere. Así mismo, estos reducidos porcentajes de colisiones internas pueden justificar los buenos resultados obtenidos anteriormente en la Tabla \ref{respp}. Incluso observando las tablas de mayores dimensiones no existe ninguna con un porcentaje de colisiones internas por encima del 70 por ciento, a la vez que únicamente nueve tablas de las 54 totales superan el 50 por ciento de colisiones internas. La mayor ventaja de tener estos porcentajes tan reducidos reside en el elevado número de colisiones de la función resumen que estarán cubiertas respecto a las tablas que emplean una configuración de funciones de reconstrucción diferente. De esta manera, las tablas que hacen uso del patrón reducido de funciones de reconstrucción prometen generar muy buenos resultados.

Por último, en cuanto a las tablas que emplean el denominado patrón extenso (\textbf{R1 + R2 + R2 + R1 + R1 + R2 + R2 + R2}) se observan los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{g}{0.00\%} & \textcolor{g}{0.40\%} & \textcolor{g}{0.67\%} & \textcolor{g}{0.80\%} & \textcolor{g}{1.27\%} & \textcolor{g}{1.70\%} & \textcolor{g}{2.04\%} & \textcolor{g}{3.18\%} & \textcolor{g}{6.70\%} \\ \cline{2-11}
		& 100 & \textcolor{g}{1.20\%} & \textcolor{g}{1.20\%} & \textcolor{g}{1.60\%} & \textcolor{g}{2.30\%} & \textcolor{g}{3.93\%} & \textcolor{g}{4.80\%} & \textcolor{g}{5.60\%} & \textcolor{g}{11.20\%} & \textcolor{g}{20.63\%} \\ \cline{2-11}
		& 200 & \textcolor{g}{2.40\%} & \textcolor{g}{4.60\%} & \textcolor{g}{7.87\%} & \textcolor{g}{9.50\%} & \textcolor{g}{14.67\%} & \textcolor{g}{17.55\%} & \textcolor{g}{20.28\%} & \textcolor{b}{33.68\%} & \textcolor{y}{50.76\%} \\ \cline{2-11}
		& 400 & \textcolor{g}{4.00\%} & \textcolor{g}{8.00\%} & \textcolor{g}{12.80\%} & \textcolor{g}{16.50\%} & \textcolor{g}{23.53\%} & \textcolor{b}{28.25\%} & \textcolor{b}{32.44\%} & \textcolor{b}{48.94\%} & \textcolor{y}{65.97\%} \\ \cline{2-11}
		& 500 & \textcolor{g}{3.60\%} & \textcolor{g}{4.60\%} & \textcolor{g}{7.87\%} & \textcolor{g}{10.20\%} & \textcolor{g}{15.73\%} & \textcolor{g}{18.80\%} & \textcolor{g}{22.12\%} & \textcolor{b}{36.64\%} & \textcolor{y}{54.28\%} \\ \cline{2-11}
		& 1000 & \textcolor{g}{10.40\%} & \textcolor{g}{21.80\%} & \textcolor{b}{30.80\%} & \textcolor{b}{36.80\%} & \textcolor{b}{45.33\%} & \textcolor{y}{51.30\%} & \textcolor{y}{55.88\%} & \textcolor{r}{70.64\%} & \textcolor{r}{82.47\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de colisiones para las tablas empleando el patrón extenso}
	\label{colPG}
\end{table}

Puede observarse como las tablas con esta configuración poseen menor número de colisiones internas que las anteriores en la Tabla \ref{colR1}, lo cual era de esperar, ya que el objetivo de establecer este patrón era forzar una reducción en el número de colisiones internas en las tablas. Lo sorprendente en esta caso es que hay unos porcentajes de colisiones internas muy similares a los de la Tabla \ref{colR1R2} (\textbf{R1 + R2}), aunque algo mejores. Esto resulta bastante inesperado, ya que la concatenación de funciones de reconstrucción conforma un patrón significativamente más simple, dando a entender que produciría una mayor cantidad de colisiones internas, empeorando los resultados. Otro hecho sorprendente en este caso es que las tablas que emplean el patrón reducido resulten mejores en cuanto al porcentaje de colisiones internas respecto al patrón extenso, siendo esta mejora más que notable.

\section{Resultados finales}

Habiendo obtenido los porcentajes de colisiones internas para las tablas con cada una de las combinaciones de funciones de reconstrucción, es el momento de realizar el ataque del arco iris con ellas. De esta forma se espera determinar qué tamaño de tabla es el ideal en cuanto a contraseñas rotas, tiempo empleado en su generación y memoria requerida para su almacenamiento. En principio lo más lógico sería esperar que las tablas con menor número de colisiones internas fueran las que mejor rendimiento tuvieran, ya que cuantas menos colisiones se den lugar en una tabla mayor será el número de contraseñas cubiertas por esa tabla. Siguiendo esta lógica, las tablas con mayor éxito deberían de ser las que hacen uso del patrón reducido (\textbf{R1 + R2 + R2}), ya que presentan una diferencia significante en sus porcentajes de colisiones, como se ha visto en la Tabla \ref{colpp}.

Como ya se ha hecho anteriormente en el apartado \ref{primeras pruebas}, cada una de las tablas que se pretende analizar tendrá la tarea de atacar los mismos valores \hash~de las contraseñas aleatorias generadas en el apartado \ref{contraseñas}, obteniendo el porcentaje de contraseñas rotas respecto al total de contraseñas a romper, indicando la cantidad de colisiones encontradas para la función resumen CRC-32.

Comenzando como es habitual por las tablas que tan sólo hacen uso de la función de reconstrucción con la operación módulo un millón (\textbf{R1}) se obtienen los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{r}{14.6\%} & \textcolor{r}{27.9\%} & \textcolor{r}{39.0\%} & \textcolor{r}{46.6\%} & \textcolor{r}{59.4\%} & \textcolor{r}{67.8\%} & \textcolor{y}{73.8\%} & \textcolor{b}{87.4\%} & \textcolor{b}{94.7\%} \\ \cline{2-11}
		& 100 & \textcolor{r}{22.1\%} & \textcolor{r}{41.9\%} & \textcolor{r}{55.8\%} & \textcolor{r}{65.8\%} & \textcolor{y}{77.2\%} & \textcolor{y}{81.6\%} & \textcolor{b}{85.9\%} & \textcolor{b}{92.3\%} & \textcolor{g}{96.4\%} \\ \cline{2-11}
		& 200 & \textcolor{r}{24.0\%} & \textcolor{r}{46.2\%} & \textcolor{r}{61.2\%} & \textcolor{y}{71.3\%} & \textcolor{y}{81.6\%} & \textcolor{b}{87.7\%} & \textcolor{b}{91.0\%} & \textcolor{g}{95.2\%} & \textcolor{g}{97.7\%} \\ \cline{2-11}
		& 400 & \textcolor{r}{23.7\%} & \textcolor{r}{45.0\%} & \textcolor{r}{60.5\%} & \textcolor{r}{69.9\%} & \textcolor{y}{82.1\%} & \textcolor{b}{88.5\%} & \textcolor{b}{91.8\%} & \textcolor{g}{96.0\%} & \textcolor{g}{98.3\%} \\ \cline{2-11}
		& 500 & \textcolor{r}{23.5\%} & \textcolor{r}{44.3\%} & \textcolor{r}{58.2\%} & \textcolor{r}{67.0\%} & \textcolor{y}{78.3\%} & \textcolor{y}{84.1\%} & \textcolor{b}{87.9\%} & \textcolor{b}{94.6\%} & \textcolor{g}{97.9\%} \\ \cline{2-11}
		& 1000 & \textcolor{r}{22.7\%} & \textcolor{r}{42.4\%} & \textcolor{r}{55.1\%} & \textcolor{r}{63.5\%} & \textcolor{y}{72.7\%} & \textcolor{y}{77.6\%} & \textcolor{y}{80.7\%} & \textcolor{b}{86.2\%} & \textcolor{b}{89.3\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas que emplean \textbf{R1}}
	\label{exR1}
\end{table}

Como era de esperar, las tablas de menor tamaño no realizan un buen trabajo a la hora de adivinar contraseñas. Aunque dichas tablas tenían porcentajes de colisiones internas realmente bajos, puede observarse ahora como esa característica no es suficiente para romper muchas contraseñas. Hace falta que las tablas posean al menos 1.000 filas para comenzar a ser efectivas, y una vez superan las 2.000 filas los resultados encontrados son en su mayoría satisfactorios. En esta ocasión no se han generado tablas con efectividad perfecta, es decir, con un porcentaje de éxito del 100\%, aunque algunas tablas se han quedado a las puertas de conseguirlo.

Es interesante también observar que la profundidad ideal para las tablas con esta configuración es de 400 columnas para las tablas con más de 1.000 filas, lo cual muestra como una mayor profundidad de tabla no se traduce en un porcentaje de éxito más elevado. Esto es debido a que cuanto más se aumenta la profundidad de una tabla más veces se genera el valor \hash~de una contraseña para ser reconstruido a continuación, con lo cual aumenta la probabilidad de generar colisiones en la tabla, reduciendo el número de contraseñas cubiertas por dicha tabla, resultando en un menor porcentaje de éxito.

Viendo estos resultados, si se pretende emplear la tabla de menor tamaño posible que sea aceptable a la hora de romper contraseñas, habría de emplearse la tabla de dimensiones $m =$ 2.000, $t =$ 200, mientras que los mejores resultados los brinda la tabla de dimensiones $m =$ 10.000, $t =$ 400.

Pasando ahora a las tablas que emplean únicamente la función de reconstrucción con el \hash~en hexadecimal (\textbf{R2}) se obtienen los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{r}{15.9\%} & \textcolor{r}{29.7\%} & \textcolor{r}{40.2\%} & \textcolor{r}{48.8\%} & \textcolor{r}{61.2\%} & \textcolor{r}{69.7\%} & \textcolor{y}{76.0\%} & \textcolor{b}{88.6\%} & \textcolor{b}{94.4\%} \\ \cline{2-11}
		& 100 & \textcolor{r}{22.2\%} & \textcolor{r}{41.7\%} & \textcolor{r}{56.2\%} & \textcolor{r}{66.2\%} & \textcolor{y}{76.9\%} & \textcolor{y}{82.8\%} & \textcolor{b}{87.0\%} & \textcolor{b}{93.4\%} & \textcolor{g}{97.1\%} \\ \cline{2-11}
		& 200 & \textcolor{r}{24.1\%} & \textcolor{r}{44.4\%} & \textcolor{r}{61.2\%} & \textcolor{y}{70.3\%} & \textcolor{y}{82.1\%} & \textcolor{b}{87.3\%} & \textcolor{b}{90.2\%} & \textcolor{b}{94.3\%} & \textcolor{g}{97.4\%} \\ \cline{2-11}
		& 400 & \textcolor{r}{22.1\%} & \textcolor{r}{41.0\%} & \textcolor{r}{57.0\%} & \textcolor{r}{64.7\%} & \textcolor{y}{74.6\%} & \textcolor{y}{78.9\%} & \textcolor{y}{82.1\%} & \textcolor{b}{90.1\%} & \textcolor{b}{93.8\%} \\ \cline{2-11}
		& 500 & \textcolor{r}{21.1\%} & \textcolor{r}{38.2\%} & \textcolor{r}{53.1\%} & \textcolor{r}{60.8\%} & \textcolor{y}{69.3\%} & \textcolor{y}{74.9\%} & \textcolor{y}{77.6\%} & \textcolor{y}{81.9\%} & \textcolor{b}{85.3\%} \\ \cline{2-11}
		& 1000 & \textcolor{r}{20.5\%} & \textcolor{r}{35.6\%} & \textcolor{r}{48.0\%} & \textcolor{r}{57.1\%} & \textcolor{y}{69.4\%} & \textcolor{y}{73.8\%} & \textcolor{y}{76.1\%} & \textcolor{y}{79.3\%} & \textcolor{y}{79.6\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas que emplean \textbf{R2}}
	\label{exR2}
\end{table}

Como se puede observar, aunque para las tablas más pequeñas se han obtenido mejores resultados, en cuanto las dimensiones aumentan los resultados empeoran respecto a los anteriores. En esta ocasión se han generado el mismo número de tablas con un porcentaje de éxito por debajo del 70\%, pero existen más tablas que no llegan a ser aceptables, así como menos tablas con un buen rendimiento. Incluso la mejor de estas tablas rinde peor que la mejor de las anteriores (97'40\% $<$ 98'30\%). Se puede asumir que este empeoramiento es debido al mayor porcentaje de colisiones internas de estas tablas (Tabla \ref{colR2}) respecto a las anteriores (Tabla \ref{colR1}). Otra diferencia que se puede apreciar al comparar estos resultados con los obtenidos en la Tabla \ref{exR1} es que, en esta ocasión, la profundidad de tabla ideal parece ser $t =$ 200, lo cual es algo razonable debido al mayor número de colisiones, ya que como se ha explicado antes, mayor profundidad equivale a más colisiones internas.

En esta ocasión, de nuevo, la tabla de menor tamaño con un rendimiento aceptable ha de tener 2.000 filas.

Atacando las contraseñas con las tablas que entrelazan ambas funciones de reconstrucción (\textbf{R1 + R2}) se obtiene:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{r}{15.5\%} & \textcolor{r}{29.4\%} & \textcolor{r}{42.5\%} & \textcolor{r}{51.5\%} & \textcolor{r}{65.8\%} & \textcolor{y}{75.9\%} & \textcolor{y}{82.4\%} & \textcolor{g}{96.1\%} & \textcolor{g}{98.8\%} \\ \cline{2-11}
		& 100 & \textcolor{r}{23.8\%} & \textcolor{r}{45.4\%} & \textcolor{r}{63.3\%} & \textcolor{y}{74.5\%} & \textcolor{b}{88.3\%} & \textcolor{b}{93.8\%} & \textcolor{g}{96.2\%} & \textcolor{g}{99.4\%} & \textcolor{g}{99.9\%} \\ \cline{2-11}
		& 200 & \textcolor{r}{24.4\%} & \textcolor{r}{47.3\%} & \textcolor{r}{68.2\%} & \textcolor{y}{83.6\%} & \textcolor{b}{94.4\%} & \textcolor{g}{97.2\%} & \textcolor{g}{98.1\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 400 & \textcolor{r}{24.4\%} & \textcolor{r}{45.3\%} & \textcolor{r}{64.1\%} & \textcolor{y}{77.3\%} & \textcolor{b}{92.6\%} & \textcolor{g}{96.8\%} & \textcolor{g}{98.1\%} & \textcolor{g}{99.8\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 500 & \textcolor{r}{24.2\%} & \textcolor{r}{44.5\%} & \textcolor{r}{62.30\%} & \textcolor{y}{74.4\%} & \textcolor{b}{89.9\%} & \textcolor{g}{95.4\%} & \textcolor{g}{97.7\%} & \textcolor{g}{99.6\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 1000 & \textcolor{r}{22.6\%} & \textcolor{r}{39.3\%} & \textcolor{r}{53.1\%} & \textcolor{r}{63.1\%} & \textcolor{y}{77.3\%} & \textcolor{b}{85.9\%} & \textcolor{b}{89.9\%} & \textcolor{g}{95.4\%} & \textcolor{g}{97.9\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas que emplean la concatenación de funciones de reconstrucción}
	\label{exR1R2}
\end{table}

Como ya ocurriera en las primeras pruebas realizadas en el apartado \ref{primeras pruebas}, las tablas que emplean la secuencia de funciones de reconstrucción \textbf{R1 + R2} consiguen romper un mayor número de contraseñas que aquellas tablas que tan sólo utilizan una función de reconstrucción. El número de tablas con un rendimiento pobre se ha reducido, mientras que ha aumentado de forma significativa la cantidad de tablas idóneas, algunas de ellas llegando incluso a ser capaces de romper todas las contraseñas almacenadas. Al igual que ha ocurrido con las tablas del arco iris anteriores (Tabla \ref{exR2}), la profundidad ideal es de $t = 200$, lo cual permite un ahorro de tiempo más que notable en el proceso de construcción de las tablas.

En este caso se ha visto reducido el número mínimo de filas necesarias para que una tabla sea considerada como aceptable, con $m = $1.500. También se ha podido ver que con una configuración de funciones de reconstrucción apropiada no es necesario generar tablas de más de 10.000 filas para encontrar todas las colisiones almacenadas, lo cual permite reducir los requerimientos de memoria significativamente.

Realizando el ataque con las tablas que emplean el denominado patrón reducido (\textbf{R1 + R2 + R2}) pueden obtenerse los siguientes resultados:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{r}{17.0\%} & \textcolor{r}{32.0\%} & \textcolor{r}{45.6\%} & \textcolor{r}{55.5\%} & \textcolor{y}{71.0\%} & \textcolor{y}{82.0\%} & \textcolor{b}{88.2\%} & \textcolor{g}{98.0\%} & \textcolor{g}{99.8\%} \\ \cline{2-11}
		& 100 & \textcolor{r}{22.9\%} & \textcolor{r}{44.7\%} & \textcolor{r}{63.6\%} & \textcolor{y}{76.7\%} & \textcolor{b}{91.8\%} & \textcolor{g}{96.5\%} & \textcolor{g}{98.5\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 200 & \textcolor{r}{24.4\%} & \textcolor{r}{48.0\%} & \textcolor{r}{69.4\%} & \textcolor{b}{85.8\%} & \textcolor{g}{97.3\%} & \textcolor{g}{99.3\%} & \textcolor{g}{99.7\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 400 & \textcolor{r}{24.5\%} & \textcolor{r}{47.8\%} & \textcolor{y}{70.9\%} & \textcolor{b}{88.0\%} & \textcolor{g}{96.0\%} & \textcolor{g}{99.0\%} & \textcolor{g}{99.5\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 500 & \textcolor{r}{24.6\%} & \textcolor{r}{48.0\%} & \textcolor{y}{70.5\%} & \textcolor{b}{88.0\%} & \textcolor{g}{97.2\%} & \textcolor{g}{99.3\%} & \textcolor{g}{99.7\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 1000 & \textcolor{r}{23.6\%} & \textcolor{r}{43.9\%} & \textcolor{r}{62.7\%} & \textcolor{y}{80.5\%} & \textcolor{g}{95.6\%} & \textcolor{g}{99.1\%} & \textcolor{g}{99.8\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas que emplean patrón reducido}
	\label{expp}
\end{table}

Estos resultados son mejores que los obtenidos con la concatenación de las funciones de reconstrucción. Las tablas generadas mediante esta configuración requieren un tamaño mínimo de tabla para obtener buenos resultados de 1.500 filas. En esta ocasión también se han obtenido tablas capaces de encontrar todas las colisiones buscadas, requiriendo la mitad de filas para que así sea respecto a las tablas de la configuración anterior, en la Tabla \ref{exR1R2}. De estas tablas que rompen todas las contraseñas, la de menor tamaño corresponde a unas dimensiones de 5.000 $\times$ 100, lo cual está por debajo del dominio $N$ establecido, ya que en principio esta tabla cubre únicamente la mitad de contraseñas del dominio. Hay otro hecho característico en estas tablas, el cual corresponde con la profundidad ideal. Si bien para cualquiera de los resultados anteriores existe cierto número de columnas que presenta el mejor rendimiento, en este para no se aprecia un único valor de $t$ que brinde los mejores resultados para cada valor de $m$.

Por último, observando los resultados obtenidos con tablas que emplean el denominado patrón extenso (\textbf{R1 + R2 + R2 + R1 + R1 + R2 + R2 + R2}) se obtiene:

\def\arraystretch{1.5}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{\begin{tabular}{|c|r|c|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{6}{*}{$t$} & 50 & \textcolor{r}{18.9\%} & \textcolor{r}{36.2\%} & \textcolor{r}{50.9\%} & \textcolor{r}{64.7\%} & \textcolor{y}{81.8\%} & \textcolor{b}{90.5\%} & \textcolor{b}{94.8\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 100 & \textcolor{r}{23.6\%} & \textcolor{r}{47.0\%} & \textcolor{r}{67.0\%} & \textcolor{y}{83.1\%} & \textcolor{g}{96.9\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 200 & \textcolor{r}{24.4\%} & \textcolor{r}{47.7\%} & \textcolor{r}{68.9\%} & \textcolor{y}{87.8\%} & \textcolor{g}{99.4\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 400 & \textcolor{r}{24.0\%} & \textcolor{r}{45.9\%} & \textcolor{r}{65.3\%} & \textcolor{y}{83.1\%} & \textcolor{g}{99.9\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 500 & \textcolor{r}{24.1\%} & \textcolor{r}{47.7\%} & \textcolor{r}{69.1\%} & \textcolor{b}{88.8\%} & \textcolor{g}{99.8\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \cline{2-11}
		& 1000 & \textcolor{r}{22.4\%} & \textcolor{r}{39.0\%} & \textcolor{r}{51.8\%} & \textcolor{r}{63.0\%} & \textcolor{y}{81.8\%} & \textcolor{g}{95.8\%} & \textcolor{g}{99.7\%} & \textcolor{g}{100\%} & \textcolor{g}{100\%} \\ \hline
		& & 250 & 500 & 750 & 1000 & 1500 & 2000 & 2500 & 5000 & 10000 \\ \hline
		& & \multicolumn{9}{c|}{$m$} \\ \hline
	\end{tabular}}
	\caption{Porcentajes de éxito para las tablas que emplean patrón extenso}
	\label{exPG}
\end{table}

Los resultados obtenidos en este caso pueden clasificarse como los mejores de entre todas las configuraciones distintas, al igual que ya ocurriera en la primera tanda de pruebas en el apartado \ref{primeras pruebas}. Se han obtenido una gran cantidad de tablas capaces de encontrar todas las colisiones buscadas, un total de 18 de las 54 totales, exactamente un tercio de todas las tablas con esta configuración. De todas ellas, la que tiene una menor dimensión es aquella con $m = $2.000 filas y $t = $200 columnas, la cual en principio debería cubrir tan sólo un 40 por ciento de las contraseñas del dominio $N$. También cambia el valor ideal del parámetro $t$, el cual en esta ocasión es de 500 columnas. Esto se le atribuye a el patrón establecido, ya que al desarrollarse durante ocho entradas consecutivas requiere de una profundidad de tabla mayor para obtener buenos resultados.

Estos resultados muestran la importancia de averiguar una buena configuración de funciones de reconstrucción, ya que la calidad de los mismos aumentará de manera significativa si se obtiene una buena configuración.

\section{Comparación y discusión}\label{discusión}

%\subsection{Clasificación de las configuraciones} 

Tras implementar el ataque del arco iris con las nuevas tablas haciendo uso de tamaños de tabla diferentes y representar los resultados obtenidos, las configuraciones establecidas podrían clasificarse de la siguiente manera empleando como criterio de clasificación la cantidad de colisiones encontradas para la función resumen CRC-32:

\begin{enumerate}

    \item Patrón extenso

    \item Patrón reducido
    
    \item Concatenación de funciones de reconstrucción
    
    \item Uso exclusivo de \textbf{R1}
    
    \item Uso exclusivo de \textbf{R2}
    
\end{enumerate}

%\subsection{Motivos causantes de esta clasificación}

Una vez observada esta clasificación de los resultados se puede tratar de establecer los motivos por los cuales se da lugar dicha clasificación para esta implementación en concreto. De entre ellos, los dos motivos con mayor peso son los siguientes:

\begin{itemize}

    \item \textbf{Variedad en la reconstrucción}: Como queda reflejado, emplear únicamente una función de reconstrucción brinda los peores resultados. Tras esta observación, es coherente pensar que emplear una combinación de ambas funciones asegurará un mejor rendimiento, lo cual efectivamente ocurre en este caso. A la hora de elegir una combinación de funciones de reconstrucción se ha de tener en cuenta el comportamiento de cada función por separado, siendo el porcentaje de colisiones internas de las tablas uno de los aspectos más importantes. Esto queda reflejado si se comparan los resultados obtenidos con los dos patrones establecidos respecto a las demás configuraciones, ya que la diferencia en la calidad de los resultados respecto a los demás resulta muy notoria.
    
	\item \textbf{Colisiones internas de las tablas}: Aunque este aspecto por sí sólo no es el más importante, es obvio que tiene un impacto significativo a la hora de encontrar colisiones para una función resumen. Un buen ejemplo para reflejar la importancia de mantener un número reducido de colisiones internas se encuentra en las tablas que hacen uso exclusivamente de la función de reconstrucción \textbf{R2} (Tabla \ref{colR2}), ya que dichas tablas son las que poseen un mayor número de colisiones internas y a la vez presentan los peores resultados (Tabla \ref{exR2}). A la vez, los resultados obtenidos por las tablas que emplean los patrones establecidos (reducido y extenso) deben parte de su calidad a la reducción de sus colisiones internas con respecto a las tablas de las demás configuraciones, ya que esto significa que cubren una mayor cantidad de colisiones de la función resumen. La clave del éxito de una tabla en cuanto a su porcentaje de colisiones internar se refiere reside en ser capaz de cubrir un rango suficiente de colisiones de la función \hash.
    
\end{itemize}

Una vez analizados los resultados obtenidos, se debe tener en cuenta que este es un caso particular de esta implementación, es decir, estos resultados se han dado de esta forma debido a la elección de la función \hash~ y dominio de contraseñas a atacar. Si se eligiera atacar una función \hash~que produjera \hashes~de mayor tamaño, manteniendo las mismas funciones de reconstrucción y configuraciones vistas, probablemente los porcentajes de colisiones internas de las tablas se verían reducidos, ya que con valores \hash~más largos disminuye su probabilidad. Este también sería el caso si se atacara un dominio de contraseñas de mayor longitud aunque se mantuviese el uso de la función \hash~CRC-32, ya que dicha función siempre genera valores \hash~de 32 bits de longitud, por lo cual las funciones de reconstrucción seguirían recibiendo como entrada cadenas de 32 bits de longitud pero producirían como salida contraseñas de dicha longitud mayor, reduciendo de esta forma la probabilidad de generar colisiones internas.

Otro de los aspectos brevemente comentados anteriormente sobre el cual se puede expandir es la escalabilidad del ataque del arco iris. Si para la implementación desarrollada en este caso se decidiera atacar una función \hash~diferente o un dominio de contraseñas que contuviera un mayor número de ellas, los cambios necesarios en la implementación serían mínimos, siendo la diferencia más notable un aumento en los tiempos empleados en construcción de tablas y búsqueda de contraseñas en las mismas, mientras la calidad de los resultados se mantendría en un rango cercano a los aquí obtenidos. Este es uno de los motivos por el cual el ataque del arco iris ha resultado ser tan eficiente, ya que es suficiente con implementarlo una primera vez para una función \hash~y dominio concretos para tener la capacidad de implementar el ataque en una variedad de condiciones distintas, requiriendo generalmente pequeños cambios para cada condición específica, siendo una condición una tupla de función \hash~y dominio de contraseñas a atacar.

En cuanto al concepto de las funciones de reconstrucción cabe destacar varios aspectos de vital importancia para su correcto comportamiento en el ataque del arco iris. Principalmente, se requieren dos características fundamentales que cualquier función de reconstrucción ha de conocer de antemano, sin las cuales le será imposible realizar un buen trabajo:

\begin{itemize}

    \item \textbf{Longitud de las cadenas de entrada y salida}: un aspecto crucial para poder establecer el método de reconstrucción de valores \hash~a textos válidos. En el caso de no tener conocimiento de dichas longitudes se correría el riesgo de producir textos no válidos para el dominio establecido. Además, puede resultar de gran utilidad, ya que se pueden establecer relaciones entre los tamaños de las cadenas de entrada y salida que faciliten la obtención de la función de reconstrucción. 
    
    \item \textbf{Caracteres permitidos en el dominio de textos válidos}: al igual que ocurre con el tamaño de las cadenas, la función de reconstrucción requerirá tener conocimiento de los caracteres que las conformen, para imposibilitar el caso de generar una reconstrucción que quede fuera de los límites establecidos por el dominio. Un claro ejemplo podría ser que, tomando el dominio de contraseñas $N$ de la implementación vista en el capítulo anterior, cualquier función de reconstrucción empleada en ese caso jamás debería producir una cadena con uno o más de sus caracteres distintos de los números del 0 al 9.
    
\end{itemize}

Otro aspecto que resulta también importante aunque no lo es tanto que los anteriores es la velocidad de reconstrucción de valores \hash~a contraseñas, ya que es una operación que se va a aplicar tan a menudo como la función resumen elegida durante cualquiera de las fases del ataque del arco iris. También es importante destacar que el hecho de que una función de reconstrucción que sea peor que otra diferente para una implementación específica (es decir, que genere peores resultados que otra) no significa que vaya a ser siempre así. Podría encontrarse otra implementación diferente, con otra función \hash~y dominio de contraseñas para los cuales la función que anteriormente brindaba peores resultados funcione mejor. Esto puede considerarse como consecuencia de lo visto en~\cite{nofreelunch}. Por este motivo generalmente resulta beneficioso tratar de utilizar más de una función de reconstrucción para una misma implementación, ya que de esta forma se puede determinar la mejor función o configuración de funciones, como se ha realizado en este proyecto.

La estructura de datos empleada para representar la tabla también resulta una decisión importante, aunque el grado de importancia dependerá del tamaño del dominio que se pretende atacar. En la implementación aquí presentada, al ser el dominio de un tamaño considerado pequeño, incluso las tablas más grandes no han llegado a tardar más de tres minutos tanto en su generación como al atacar las contraseñas, por lo cual no se ha requerido buscar la mayor eficiencia posible en cuanto a la estructura de datos utilizada. En el caso de realizar el ataque contra un dominio de tamaño considerable, el cual con la implementación actual pudiera multiplicar los tiempos requeridos, se habría de fijar como objetivo adicional encontrar la estructura de datos más eficiente. De nuevo, esto entra dentro de la escalabilidad del ataque del arco iris, ya que por mucho que la estructura de datos varíe, la forma de llevar a cabo el ataque permanecerá siendo la misma.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 CONCLUSIONES                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusiones}

Tras observar la idea general de la primera implementación de Hellman \cite{hellman} y tener en cuenta pero finalmente no aplicar la mejora propuesta por Rivest \cite{rivest}, el ataque del arco iris lleva estos conceptos más allá, con el objetivo de mejorar los resultados obtenidos anteriormente y también adaptar estas implementaciones a las nuevas necesidades establecidas por los avances informáticos.

Tras establecer el funcionamiento general en cuanto a la generación de las tablas se refiere, el paso siguiente corresponde a determinar una o varias funciones de reconstrucción a emplear durante dicha generación. Tras varias pruebas con diversas funciones se optó por emplear inicialmente la función \textbf{R1}, la cual proporcionó resultados razonablemente buenos. Tras ello, surgió la duda de si esta función, por sí misma, no era la más apropiada para este ataque, por lo cual se pasó a emplear la segunda función de reconstrucción \textbf{R2}, la cual no consiguió mejorar los resultados obtenidos anteriormente por la función \textbf{R1}. Esto sirvió para reflejar la importancia de concebir una función de reconstrucción apropiada, la cual variará según la implementación que se esté llevando a cabo. En un principio tan sólo se iban a dar lugar dos configuraciones de tabla diferentes, empleando exclusivamente una de las funciones de reconstrucción en cada configuración. Tras la obtención de los resultados generados a raíz de implementar el ataque del arco iris con estas dos configuraciones, surgió la idea de combinar ambas funciones de reconstrucción, con el objetivo en mente de reducir el número de colisiones internas de las tablas, permitiendo aumentar la cantidad de colisiones de la función resumen cubiertas por una tabla.

En cuanto a esto, la primera propuesta fue entrelazar ambas funciones (\textbf{R1 + R2}), mientras que una vez generadas estas tablas se trató de reducir todavía más las colisiones internas de las mismas mediante el uso de patrones de mayor longitud que esta concatenación de funciones. El primero de estos añadía únicamente un paso más (\textbf{R1 + R2 + R2}), mientras que el segundo resultó ser de mayor longitud (\textbf{R1 + R2 + R2 + R1 + R1 + R2 + R2 + R2}). De esta manera es establecieron los denominados patrones reducido y extenso respectivamente, los cuales consiguieron con éxito reducir la cantidad de colisiones internas en sus tablas respecto a las demás configuraciones.

%Habiendo implementado el ataque del arco iris con un total de 370 tablas diferentes, variando las dimensiones y el uso de funciones de reconstrucción de las mismas, se ha podido observar el rendimiento en cuanto a la cantidad de contraseñas rotas se refiere.

En una primera instancia se optó por generar tablas del arco iris con dimensiones no menores de $m =$ 1.000 filas, debido a que generar tablas con un menor número de filas habría de compensarse con una mayor profundidad para cubrir todo el dominio $N = $1.000.000, lo cual podría resultar en un aumento notable del número de colisiones internas en dichas tablas. Tras realizar estos primeros ataques empleando los tamaños de tabla iniciales con las cinco configuraciones distintas y obtener sus resultados, es posible establecer unas primeras conclusiones sobre ellos.

Para empezar, prestando atención antes que nada a la calidad de los resultados en sí, es decir, priorizando las tablas con porcentajes de éxito mayores, queda claro que la mejor combinación de funciones de reconstrucción se da empleando el patrón extenso, visto en la Figura \ref{filaPG}, como puede observarse en las Tablas \ref{resPG} y \ref{exPG}. La segunda conclusión clara que puede establecerse es que, una vez se emplean tablas de 5.000 filas o más, cualquiera de las tablas empleadas en este primer ataque consigue obtener la mayoría de las colisiones de la función \hash. En el caso de esta implementación en concreto, esto sucede con tal cantidad de filas debido a que el dominio $N$ no resulta ser excesivamente elevado. También cabe destacar que, aunque para estos primeros ataques se emplearon tablas llegando incluso a tener un millón de filas que cubrían todas las contraseñas o incluso superaban el dominio establecido, esta práctica no será factible en aplicaciones con un dominio mayor. El motivo de generar dichas tablas en esta ocasión fue el tratar de llegar lo más cerca posible al límite de filas. Es importante indicar que dichas tablas realmente no resultan prácticas en este ataque, ya que aunque consiguen encontras todas las colisiones para las contraseñas almacenadas, existen otras tablas de menor tamaño con las cuales se dan los mismos resultados, por lo cual serían dichas tablas más pequeñas las empleadas para realizar el ataque del arco iris, ya que se ahorraría una cantidad de tiempo considerable entre la generación de la tabla y la búsqueda de las colisiones, así como la memoria necesaria para almacenar la tabla. Por último, es fácilmente observable que las tablas que hacen uso exclusivamente de la función de reconstrucción \textbf{R2} brindan los peores resultados, aunque puedan ser considerados buenos en general. Esto fue un hecho sorprendente en primer lugar, ya que se esperaba que esta función de reconstrucción fuera capaz de generar tablas con menor cantidad de colisiones internas, lo cual no ocurrió finalmente como se puede observar en la Tabla \ref{colR2}.

Tras esta primera tanda de resultados, viendo como ya se ha dicho los elevados porcentajes de éxito para tablas con al menos 5.000 filas, el foco de atención se centró en buscar las tablas de menor dimensionalidad posible que proporcionaran resultados similares a las tablas de mayores dimensiones en cuanto a la calidad de los mismos se refiere. Para ello, se estableció el número mínimo de filas en 250, mientras que el máximo quedó en 10.000 filas. Cabe destacar que de las tablas con un número de filas reducido no se esperaba un gran rendimiento, debido a que no llegaban a cubrir el dominio $N$ en su totalidad. Aún así, generarlas y obtener sus resultados ha resultado ser necesario para poder establecer una frontera con claridad en las búsqueda por la tabla más eficiente de construir con mejores resultados. Habiendo alcanzado este punto no se estimó necesario establecer una nueva configuración de funciones de reconstrucción para las tablas, por lo cual el proceso de obtención de resultados fue idéntico al empleado en el apartado \ref{primeras pruebas}.

Una vez generadas todas las tablas necesarias con los nuevos tamaños, antes de realizar el ataque del arco iris con cada una de ellas se optó por obtener su número de colisiones internas. Esto sirvió para poder reflejar una de las dos medidas de calidad de las configuraciones de las tablas, siendo la segunda de estas medidas el porcentaje de éxito. Analizando los resultados en cuanto a los porcentajes de colisiones internas de las tablas se refiere, se aprecia que la función de reconstrucción \textbf{R2} es la peor en este aspecto de manera considerable (Tabla \ref{colR2}), mientras que el patrón reducido (Tabla \ref{colpp}) genera las tablas con el menor número de colisiones internas, lo cual en principio podría emplearse como argumento para predecir que estas tablas conseguirían encontrar el mayor número de colisiones de la función resumen atacada.

Finalmente, una vez implementado el ataque del arco iris empleando las tablas con los nuevos tamaños establecidos en el apartado \ref{nuevos_tamaños} y habiendo representado los resultados generados, de nuevo las configuraciones establecidas podrían clasificarse de la siguiente manera empleando como criterio de clasificación la cantidad de colisiones encontradas para la función \hash~CRC-32:

\begin{enumerate}

    \item Patrón extenso
    
    \item Patrón reducido
    
    \item Concatenación de funciones de reconstrucción
    
    \item Uso exclusivo de \textbf{R1}
    
    \item Uso exclusivo de \textbf{R2}
    
\end{enumerate}

En la sección \ref{discusión} ya han sido establecidos los motivos por los cuales se da lugar dicha clasificación en la implementación desarrollada para este proyecto. Con todo, los resultados de todas las configuraciones distintas han sido buenos en general, a la vez que han servido para reflejar la importancia de los diferentes factores de las tablas del arco iris a tener en cuenta, especialmente las dimensiones, el porcentaje de colisiones internas de las mismas y el buen uso de funciones de reconstrucción apropiadas.

Como trabajo futuro queda pendiente, además de la incesante búsqueda de la función de reconstrucción ideal, realizar la implementación propuesta por Rivest \cite{rivest} y sus puntos de control, como se ha visto en la sección \ref{puntosdist}, con el objetivo de comprobar si, en este caso, consigue mejorar los resultados obtenidos. También resultaría interesante lanzar este ataque contra una función resumen que ofrezca mayor seguridad que la función CRC-32, así como empleando un dominio de contraseñas de mayor tamaño, viendo de esta forma si la escalabilidad del ataque del arco iris permite obtener resultados suficientemente similares a los aquí vistos.

Tras todo esto, se espera que la efectividad del ataque del arco iris haya quedado suficientemente clara. Siempre que se realice este ataque con el objetivo de encontrar colisiones de una función \hash~que no utilice técnicas como el \textit{salting} o el estiramiento (explicados en la sección \ref{salt}), las tablas del arco iris serán capaces de hacerse con la gran mayoría de las colisiones deseadas. Una de las claves para dicho éxito recae en emplear funciones de reconstrucción adecuadas, para lo cual es necesario dedicar el tiempo adecuado a la experimentación con diversas de estas funciones, así como los diferentes parámetros que configuran una tabla en concreto. Como ha sido siempre habitual en la criptografía, a medida que se han ido reforzando las medidas de seguridad frente a los ataque informáticos, también se ha conseguido mejorar la efectividad de los mismos, lo cual motiva a un refuerzo mayor de la seguridad de los sistemas, formando un ciclo el cual continúa hoy en día. Si bien como ya se ha dicho, actualmente resulta sencillo inutilizar el ataque del arco iris, todavía existen sistemas que siguen siendo vulnerables a sus tablas, como por ejemplo aquellos empleadas en el almacenamiento de contraseñas en todos los sistemas operativos de Microsoft \textit{Windows} hasta llegar a \textit{Windows} 7, incluído. También  se le puede dar un uso diferente, el cual consiste en atacar dos funciones \hash~diferentes haciendo uso de la misma configuración de tablas del arco iris, para así poder comparar de seguridad de ambas funciones frente a los intentos de obtención de sus colisiones. Esto puede ser útil en aquellos casos en los cuales por especificaciones de diseño u otros motivos no sea posible hacer uso del \textit{salting} o el estiramiento. Incluso se podría hacer uso de una implementación en particular del ataque del arco iris para comparar la eficiencia de diferentes estructuras de datos, ya que estarán sometidas a las mismas operaciones. Todos estos aspectos sirven para observar que, aunque en un principio es normal pensar en el ataque del arco iris como un ataque informático más, se le puede dar diferentes usos dependiendo del objetivo que se esté tratando de cumplir.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                BIBLIOGRAFÍA                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{unsrt}
\bibliography{referencias}

%\begin{thebibliography}{10}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MODELO DE ARTÍCULO                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibitem{hellman}
%    M. E. Hellman.
%    \newblock A cryptanalytic time-memory trade-off.
%    \newblock \textit{IEEE Transactions on Information Theory}, VOL. IT-26, NO. 4, julio 1980.
%
%\bibitem{rivest}
%    D.Denning.
%    \newblock \textit{Cryptography and Data Security},
%    \newblock p.100, Addison-Wesley, 1982.
%
%\bibitem{rainbow}
%    P. Oechslin
%	\newblock \textit{Making a Faster Cryptanalytic Time-Memory Trade-Off},
%    \newblock Boneh D. (eds) Advances in Cryptology - CRYPTO 2003, Lecture Notes in Computer Science, vol 2729. Springer, Berlin, Germany.
%
%\bibitem{handbook}
%	J. Katz, A. J. Menezes, P. C. Van Oorschot, S. A. Vanstone.
%	\newblock \textit{Handbook of applied cryptography},
%	\newblock (1996), CRC press.
%
%\bibitem{birthday}
%	M.C. Borja, J. Haigh.
%	\newblock \textit{The birthday problem},
%	\newblock Significance. 2007 Sep;4(3):124-7.
%
%\end{thebibliography}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           APÈNDIXS  (Si n'hi ha!)                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\APPENDIX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         LA CONFIGURACIO DEL SISTEMA                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\chapter{Configuración del sistema}

%Por determinar

%                              FI DEL DOCUMENT                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
